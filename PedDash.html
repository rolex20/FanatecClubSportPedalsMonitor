<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PedDash Arcade - Production v19 - (fixes by ChatGPT and me)</title>
  <style>
    :root {
      --bg-color: #050508;
      --panel-bg: #0f0f16;
      --text-main: #e0e0e0;
      --text-muted: #777;
      --neon-cyan: #00f3ff;
      --neon-green: #39ff14;
      --neon-magenta: #ff00ff;
      --neon-amber: #ffbf00;
      --neon-red: #ff3333;
      --header-height: 70px;
      --tab-height: 45px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0; padding: 0;
      background-color: var(--bg-color);
      color: var(--text-main);
      font-family: "Segoe UI", Tahoma, sans-serif;
      overflow: hidden;
      width: 100vw; height: 100vh;
      display: flex; flex-direction: column;
      user-select: none;
    }

    /* Utility text colors (restored) */
    .txt-white { color: #fff; }
    .txt-green { color: var(--neon-green); }
    .txt-red { color: var(--neon-red); }
    .txt-cyan { color: var(--neon-cyan); }
    .txt-mag { color: var(--neon-magenta); }
    .txt-amb { color: var(--neon-amber); }

    /* --- Header --- */
    header {
      height: var(--header-height);
      background: linear-gradient(to bottom, #1a1a24, #0f0f16);
      border-bottom: 1px solid #333;
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 20px; flex-shrink: 0;
    }

    .brand { font-weight: bold; letter-spacing: 1px; color: var(--neon-cyan); font-size: 1.2em; text-shadow: 0 0 5px rgba(0, 243, 255, 0.4); }
    .brand span { font-size: 0.7em; color: var(--text-muted); font-weight: normal; margin-left: 10px; }

    .center-status { width: 300px; text-align: center; }
    .pill { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.85em; font-weight: bold; opacity: 0; transition: opacity 0.2s; margin: 0 5px; }
    .pill.active { opacity: 1; animation: pulse 2s infinite; }
    .pill-ffw { background: rgba(255, 191, 0, 0.1); color: var(--neon-amber); border: 1px solid var(--neon-amber); box-shadow: 0 0 10px rgba(255,191,0,0.25); }
    .pill-disc { background: rgba(255, 51, 51, 0.1); color: var(--neon-red); border: 1px solid var(--neon-red); box-shadow: 0 0 10px rgba(255,51,51,0.25); }

    @keyframes pulse { 0% { box-shadow: 0 0 5px currentColor; } 50% { box-shadow: 0 0 15px currentColor; } 100% { box-shadow: 0 0 5px currentColor; } }

    .lag-summary { text-align: right; font-family: monospace; display: flex; flex-direction: column; justify-content: center; }
    .lag-main { font-size: 1.6em; color: var(--text-main); font-weight: bold; line-height: 1.1; }
    .lag-details { font-size: 1.1em; color: var(--text-muted); margin-top: 2px; }
    .lag-metric { cursor: help; text-decoration: underline; text-decoration-style: dotted; text-underline-offset: 3px; }
    .lag-metric:hover { color: #fff; }

    /* --- Navigation --- */
    nav { height: var(--tab-height); background-color: #0f0f16; display: flex; border-bottom: 1px solid #333; flex-shrink: 0; }
    .tab-btn { background: transparent; border: none; color: var(--text-muted); padding: 0 25px; font-size: 1em; cursor: pointer; border-right: 1px solid #222; transition: all 0.2s; }
    .tab-btn:hover { color: #fff; background: #161620; }
    .tab-btn.active { color: var(--neon-cyan); background: #1a1a24; box-shadow: inset 0 -3px 0 var(--neon-cyan); }

    /* --- Main Content --- */
    main { flex-grow: 1; position: relative; overflow: hidden; padding: 15px; }
    .tab-content { display: none; height: 100%; width: 100%; flex-direction: column; }
    .tab-content.active { display: flex; }

    /* --- Racing Tab --- */
    .gauges-container { display: flex; justify-content: center; align-items: center; gap: 60px; flex-grow: 1; padding-bottom: 20px; flex-wrap: wrap; }
    .gauge-wrapper { display: flex; flex-direction: column; align-items: center; width: 320px; }
    .gauge-canvas { margin-bottom: 15px; }
    .gauge-labels { display: flex; justify-content: space-between; width: 100%; font-family: monospace; font-size: 1.8em; color: var(--text-muted); font-weight: bold; }
    .status-strip { display: flex; justify-content: center; gap: 15px; padding: 10px; background: #0f0f16; border-radius: 8px; border: 1px solid #333; margin: 0 auto 15px auto; flex-shrink: 0; max-width: 1200px; width: 100%; }
    .status-chip { padding: 5px 15px; border-radius: 4px; font-size: 0.9em; font-weight: bold; background: #222; color: #555; text-transform: uppercase; transition: all 0.2s; }
    .status-chip.active-red { background: rgba(255, 51, 51, 0.2); color: var(--neon-red); box-shadow: 0 0 8px var(--neon-red); border: 1px solid var(--neon-red); }
    .status-chip.active-amber { background: rgba(255, 191, 0, 0.2); color: var(--neon-amber); box-shadow: 0 0 8px var(--neon-amber); border: 1px solid var(--neon-amber); }
    .status-chip.active-blue { background: rgba(0, 243, 255, 0.2); color: var(--neon-cyan); box-shadow: 0 0 8px var(--neon-cyan); border: 1px solid var(--neon-cyan); }
    .status-chip.active-green { background: rgba(57, 255, 20, 0.2); color: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); border: 1px solid var(--neon-green); }
    .ticker-container { height: 100px; background: #000; border: 1px solid #333; border-radius: 4px; padding: 10px; overflow-y: hidden; font-family: Verdana,"Segoe UI", Tahoma; font-size: 1em; flex-shrink: 0; max-width: 1200px; margin: 0 auto; width: 100%; }
    /* FIX: newest-first on Racing ticker (match Signals tab) */
    .ticker-list { display: flex; flex-direction: column; }
    .ticker-item { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
    .ticker-time { color: var(--text-muted); margin-right: 10px; }

    /* --- Lag Tab --- */
    .lag-panel { display: grid; grid-template-rows: max-content 35vh; align-content: start; height: 100%; gap: 20px; }
    .lag-metrics-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
    .metric-card { background: #0f0f16; border: 1px solid #333; border-radius: 8px; padding: 15px; text-align: center; }
    .metric-card h3 { margin: 0 0 5px 0; font-size: 1em; color: var(--text-muted); }
    .metric-card .value { font-size: 1.8em; font-weight: bold; font-family: monospace; }
    .metric-avg { font-size: 0.8em; color: #555; margin-top: 5px; font-family: monospace; }
    .chart-container { background: #0f0f16; border: 1px solid #333; border-radius: 8px; padding: 15px; position: relative; overflow: hidden; }

    /* --- Signals Tab --- */
    .signals-layout { display: grid; grid-template-rows: 30vh 1fr; gap: 20px; height: 100%; }
    .waveforms-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; min-height: 0; }
    .waveform-card { background: #0f0f16; border: 1px solid #333; border-radius: 8px; padding: 10px; display: flex; flex-direction: column; position: relative; overflow: hidden; min-height: 0; }
    .waveform-card h4 { margin: 0 0 10px 0; color: var(--text-muted); font-size: 1.1em; flex-shrink: 0; }
    .events-table-container { background: #0f0f16; border: 1px solid #333; border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; min-height: 0; }
    /* Wider last column to host two export buttons */
    .events-header { background: #1a1a24; padding: 10px; display: grid; grid-template-columns: 100px 150px 1fr 280px; font-weight: bold; font-size: 1em; border-bottom: 1px solid #333; flex-shrink: 0; align-items: center; }
    .events-list { overflow-y: auto; flex-grow: 1; font-family: Verdana; font-size: 1em; }
    .event-row { display: grid; grid-template-columns: 100px 150px 1fr 280px; padding: 6px 10px; border-bottom: 1px solid #222; }
    .event-row:hover { background-color: #1a1a24; }
    .btn-export { background: #222; border: 1px solid #555; color: #fff; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 0.85em; }
    .btn-export:hover { background: #333; border-color: var(--neon-cyan); }

    /* --- Telemetry Map --- */
    .tele-container { height: 100%; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 30px; }
    .tele-group { display: flex; flex-direction: column; }
    .tele-group-header { color: var(--neon-cyan); border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 15px; font-size: 1.1em; text-transform: uppercase; font-weight: bold; }
    .tele-grid-section { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 15px; }
    .tele-card { background: #161620; border: 1px solid #333; border-radius: 6px; padding: 15px; cursor: pointer; transition: all 0.2s; }
    .tele-card:hover { border-color: var(--neon-cyan); background: #1a1a24; transform: translateY(-2px); }
    .tele-card h5 { margin: 0 0 5px 0; color: var(--text-muted); font-size: 0.85em; text-transform: uppercase; }
    .tele-card .tele-val { font-size: 1.4em; font-family: monospace; font-weight: bold; color: #fff; word-break: break-all; }
    .tele-val.warn-red { color: var(--neon-red); text-shadow: 0 0 5px var(--neon-red); }

    /* --- Config Tab --- */
    .config-panel { padding: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 40px; overflow-y: auto; }
    .config-group { background: #161620; border: 1px solid #333; border-radius: 8px; padding: 20px; }
    .config-group h3 { margin-top: 0; color: var(--neon-cyan); border-bottom: 1px solid #444; padding-bottom: 10px; }
    .form-row { margin-bottom: 15px; display: flex; flex-direction: column; }
    .form-row label { color: #aaa; font-size: 0.9em; margin-bottom: 5px; }
    .form-row input, .form-row select { background: #000; border: 1px solid #444; color: #fff; padding: 10px; font-family: monospace; font-size: 1em; }
    .form-row input[type="checkbox"] { width: 22px; height: 22px; cursor: pointer; }
    .row-inline { flex-direction: row; align-items: center; gap: 12px; }

    /* --- Modals/Tips (DOM restored) --- */
    .hover-tip { position: fixed; background: rgba(0,0,0,0.95); border: 1px solid var(--neon-cyan); color: var(--neon-cyan); padding: 8px 12px; border-radius: 4px; font-size: 0.85em; pointer-events: none; z-index: 1000; opacity: 0; transition: opacity 0.1s; transform: translateY(-100%); margin-top: -10px; }
    .hover-tip.visible { opacity: 1; }
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .modal-overlay.open { opacity: 1; pointer-events: auto; }
    .modal-card { background: #1a1a24; border: 1px solid var(--neon-cyan); box-shadow: 0 0 30px rgba(0, 243, 255, 0.3); width: 550px; max-width: 90%; padding: 25px; border-radius: 12px; position: relative; }
    .modal-card h2 { margin-top: 0; color: var(--neon-cyan); border-bottom: 1px solid #333; padding-bottom: 10px; }
    .modal-card p { color: #e0e0e0; line-height: 1.6; font-size: 1.05em; }
    .modal-close { position: absolute; top: 15px; right: 15px; background: none; border: none; color: #777; font-size: 2em; cursor: pointer; line-height: 1; }
    .modal-close:hover { color: #fff; }

    /* --- Error Handling UI --- */
    #global-error { position: fixed; bottom: 0; left: 0; width: 100%; background: #c00; color: #fff; padding: 15px; font-family: monospace; font-size: 12px; z-index: 9999; display: none; white-space: pre-wrap; overflow-y: auto; max-height: 200px; border-top: 2px solid #fff; }

    canvas { display: block; width: 100%; height: 100%; }
  </style>

  <script>
    // --- 0. EMERGENCY ERROR BOX ---
    window.onerror = function(msg, url, line, col, error) {
      const box = document.getElementById('global-error');
      if (box) {
        box.style.display = 'block';
        box.textContent += `[JS ERROR] ${msg}\nLine: ${line}, Col: ${col}\n${error ? error.stack : ''}\n\n`;
      }
      return false;
    };
  </script>
</head>

<body>
  <div id="global-error"></div>

  <header>
    <div class="brand">PedDash <span id="session-status">Telemetry Arcade</span></div>
    <div class="center-status">
      <div id="disc-indicator" class="pill pill-disc">⚠ DISCONNECTED</div>
      <div id="ffw-indicator" class="pill pill-ffw">⏩ FFW CATCH-UP</div>
    </div>
    <div class="lag-summary">
      <div class="lag-main">Latency: <span id="hdr-total-lag" class="txt-red lag-metric" data-tele-key="lagTotal">--</span> ms</div>
      <div class="lag-details">
        Prod: <span id="hdr-ped-lag" class="lag-metric" data-tele-key="producerLagMs">00</span> | Queue: <span id="hdr-brg-lag" class="lag-metric" data-tele-key="queueWaitMs">00</span> | JS: <span id="hdr-dsh-lag" class="lag-metric" data-tele-key="lagDash">00</span> | Paint: <span id="hdr-paint-lag" class="lag-metric" data-tele-key="lagPaint">00</span>
      </div>
    </div>
  </header>

  <nav>
    <button class="tab-btn active" id="btn-racing" onclick="switchTab('tab-racing')">Racing</button>
    <button class="tab-btn" id="btn-lag" onclick="switchTab('tab-lag')">Lag & Timing</button>
    <button class="tab-btn" id="btn-signals" onclick="switchTab('tab-signals')">Signals & Events</button>
    <button class="tab-btn" id="btn-telemetry" onclick="switchTab('tab-telemetry')">Data Map</button>
    <button class="tab-btn" id="btn-config" onclick="switchTab('tab-config')">Configuration</button>
  </nav>

  <main>
    <!-- Tab 1: Racing -->
    <div id="tab-racing" class="tab-content active">
      <div class="gauges-container">
        <div class="gauge-wrapper">
          <canvas id="canvas-clutch" width="300" height="300" class="gauge-canvas"></canvas>
          <div class="gauge-labels">
            <span>PHYS: <span id="lbl-clutch-phys">0%</span></span>
            <span>GAME: <span id="lbl-clutch-log">0%</span></span>
          </div>
        </div>
        <div class="gauge-wrapper">
          <canvas id="canvas-brake" width="300" height="300" class="gauge-canvas"></canvas>
          <div class="gauge-labels">
            <span>PHYS: <span id="lbl-brake-phys">0%</span></span>
            <span>GAME: <span id="lbl-brake-log">0%</span></span>
          </div>
        </div>
        <div class="gauge-wrapper">
          <canvas id="canvas-gas" width="300" height="300" class="gauge-canvas"></canvas>
          <div class="gauge-labels">
            <span>PHYS: <span id="lbl-gas-phys">0%</span></span>
            <span>GAME: <span id="lbl-gas-log">0%</span></span>
          </div>
        </div>
      </div>
      <div class="status-strip">
        <div id="status-drift" class="status-chip">Drift Alert</div>
        <div id="status-noise" class="status-chip">Rudder Noise</div>
        <div id="status-auto" class="status-chip">Auto-Adjust</div>
        <div id="status-racing" class="status-chip">Racing</div>
      </div>
      <div class="ticker-container"><div id="ticker-list" class="ticker-list"></div></div>
    </div>

    <!-- Tab 2: Lag -->
    <div id="tab-lag" class="tab-content">
      <div class="lag-panel">
        <div class="lag-metrics-grid">
          <div class="metric-card"><h3>Total (Sample → Paint)</h3><div class="value txt-red" id="card-total-paint">0 ms</div><div class="metric-avg" id="avg-total-paint">Avg: 0</div></div>
          <div class="metric-card"><h3>Total (Sample → Handler)</h3><div class="value txt-red" id="card-total-lag">0 ms</div><div class="metric-avg" id="avg-total-lag">Avg: 0</div></div>
          <div class="metric-card"><h3>Sample → Enqueue</h3><div class="value txt-cyan" id="card-ped-lag">0 ms</div><div class="metric-avg" id="avg-ped-lag">Avg: 0</div></div>
          <div class="metric-card"><h3>Enqueue → Send</h3><div class="value txt-green" id="card-brg-lag">0 ms</div><div class="metric-avg" id="avg-brg-lag">Avg: 0</div></div>
          <div class="metric-card"><h3>Send → JS Handler</h3><div class="value txt-mag" id="card-dsh-lag">0 ms</div><div class="metric-avg" id="avg-dsh-lag">Avg: 0</div></div>
        </div>
        <div class="chart-container"><canvas id="canvas-lag-chart"></canvas></div>
      </div>
    </div>

    <!-- Tab 3: Signals -->
    <div id="tab-signals" class="tab-content">
      <div class="signals-layout">
        <div class="waveforms-row">
          <div class="waveform-card"><h4>Gas Input History</h4><canvas id="canvas-wave-gas"></canvas></div>
          <div class="waveform-card"><h4>Clutch Input History</h4><canvas id="canvas-wave-clutch"></canvas></div>
        </div>
        <div class="events-table-container">
          <div class="events-header">
            <div>Time</div><div>Type</div><div>Details</div>
            <div style="display:flex; justify-content:flex-end; gap:10px;">
              <button class="btn-export" onclick="exportLogs()">Export Events CSV</button>
              <button class="btn-export" onclick="exportAlgoDebugCsv()">Export Algo Debug CSV</button>
            </div>
          </div>
          <div id="full-event-list" class="events-list"></div>
        </div>
      </div>
    </div>

    <!-- Tab 4: Telemetry -->
    <div id="tab-telemetry" class="tab-content">
      <div id="tele-container" class="tele-container"></div>
    </div>

    <!-- Tab 5: Configuration -->
    <div id="tab-config" class="tab-content">
      <div class="config-panel">
        <div class="config-group">
          <h3>Polling Control</h3>
          <div class="form-row">
            <label>Update Interval (ms) - Set 0 for Smart</label>
            <input type="number" id="cfg-interval" onchange="updateConfig('UPDATE_INTERVAL_MS', this.value)">
          </div>
          <div class="form-row">
            <label>Smart Algorithm Mode</label>
            <select id="cfg-algo" onchange="updateConfig('ALGO_MODE', this.value)">
              <option value="SMOOTH_CONVERGENCE">SMOOTH_CONVERGENCE (Recommended)</option>
              <option value="FRAME_LOCK">FRAME_LOCK</option>
              <option value="ALGO_DIGITAL_PLL">ALGO_DIGITAL_PLL (ChatGPT)</option>
              <option value="ALGO_INTEGRAL_FLOW">ALGO_INTEGRAL_FLOW</option>
              <option value="ALGO_GROK_PI">ALGO_GROK_PI</option>
              <option value="ALGO_DEEPSEEK_PI">ALGO_DEEPSEEK_PI</option>
              <option value="ALGO_QWEN_HYSTERESIS">ALGO_QWEN_HYSTERESIS</option>
              <option value="ALGO_CLAUDE_EWAP">ALGO_CLAUDE_EWAP</option>
              <option value="ALGO_LEGACY">ALGO_LEGACY</option>
            </select>
          </div>
          <div class="form-row">
            <label>Manual Update Factor</label>
            <input type="number" step="0.01" id="cfg-factor" onchange="updateConfig('MANUAL_UPDATE_FACTOR', this.value)">
          </div>
        </div>
        <div class="config-group">
          <h3>System & Debug</h3>
          <div class="form-row row-inline"><input type="checkbox" id="cfg-bounds" onchange="updateConfig('USE_BOUNDS_CHECK', this.checked)"><label>Use Bounds Check</label></div>
          <div class="form-row row-inline"><input type="checkbox" id="cfg-debug" onchange="updateConfig('ENABLE_ALGO_DEBUG', this.checked)"><label>Algorithm Debug Logging</label></div>
          <div class="form-row row-inline"><input type="checkbox" id="cfg-empty" onchange="updateConfig('LOG_EMPTY_FRAMES', this.checked)"><label>Log Empty Frames</label></div>
          <div class="form-row"><label>Max History (lines)</label><input type="number" id="cfg-history" onchange="updateConfig('MAX_HISTORY_LINES', this.value)"></div>
        </div>
      </div>
    </div>
  </main>

  <!-- Overlays (RESTORED so telemetry cards don’t crash) -->
  <div id="hover-tip" class="hover-tip">Quick Info</div>
  <div id="modal-overlay" class="modal-overlay" onclick="closeModal()">
    <div class="modal-card" onclick="event.stopPropagation()">
      <button class="modal-close" onclick="closeModal()">&times;</button>
      <h2 id="modal-title">Title</h2>
      <p id="modal-desc">Description goes here.</p>
    </div>
  </div>

  <script>
    /**
     * 1. CONFIGURATION
     */
    const config = {
      UPDATE_INTERVAL_MS: 0,
      ALGO_MODE: "ALGO_DIGITAL_PLL", // "FRAME_LOCK", "SMOOTH_CONVERGENCE", "ALGO_DIGITAL_PLL", "ALGO_INTEGRAL_FLOW", "ALGO_GROK_PI", "ALGO_DEEPSEEK_PI", "ALGO_QWEN_HYSTERESIS", "ALGO_CLAUDE_EWAP", "ALGO_LEGACY"
      MANUAL_UPDATE_FACTOR: 1.00,
      USE_BOUNDS_CHECK: true,
      ENABLE_ALGO_DEBUG: false,
      LOG_EMPTY_FRAMES: false,
      MAX_HISTORY_LINES: 1000
    };

    function initConfigControls() {
      const intervalEl = document.getElementById('cfg-interval');
      if (intervalEl) intervalEl.value = config.UPDATE_INTERVAL_MS ?? '';

      const algoEl = document.getElementById('cfg-algo');
      if (algoEl) algoEl.value = config.ALGO_MODE ?? '';

      const factorEl = document.getElementById('cfg-factor');
      if (factorEl) factorEl.value = config.MANUAL_UPDATE_FACTOR ?? '';

      const boundsEl = document.getElementById('cfg-bounds');
      if (boundsEl) boundsEl.checked = Boolean(config.USE_BOUNDS_CHECK);

      const debugEl = document.getElementById('cfg-debug');
      if (debugEl) debugEl.checked = Boolean(config.ENABLE_ALGO_DEBUG);

      const emptyEl = document.getElementById('cfg-empty');
      if (emptyEl) emptyEl.checked = Boolean(config.LOG_EMPTY_FRAMES);

      const historyEl = document.getElementById('cfg-history');
      if (historyEl) historyEl.value = config.MAX_HISTORY_LINES ?? '';
    }

    // SSE endpoint (persistent stream). Old polling endpoint is intentionally disabled.
    const BRIDGE_URL = "http://127.0.0.1:8181/events";
    const MAX_CHART_HISTORY = 300;
    const AVG_WINDOW_S = 3;

    // Centralized user-facing messages for telemetry flags
    const EVENT_MESSAGES = {
      gas_alert_triggered: {
        type: "Alert",
        message: f => `Gas Pedal Only Reached : ${f.percentReached ?? ""}% (Drift Issue)`
      },
      clutch_alert_triggered: {
        type: "Warn",
        message: () => "Rudder Noise Issue"
      },
      controller_disconnected: {
        type: "Alert",
        message: () => "Controller Lost"
      },
      controller_reconnected: {
        type: "Info",
        message: () => "Controller Reconnected"
      },
      gas_estimate_decreased: {
        type: "Warn",
        message: f => {
          const est = Number(f.best_estimate_percent);
          const estStr = Number.isFinite(est) ? est.toFixed(1).replace(/\.0+$/, '') : (f.best_estimate_percent ?? "?");
          return `New deadzone estimation: ${estStr}%`;
        }
      },
      gas_auto_adjust_applied: {
        type: "Info",
        message: f => {
          const dzOut = Number(f.gas_deadzone_out);
          const dzStr = Number.isFinite(dzOut) ? dzOut.toFixed(1).replace(/\.0+$/, '') : (f.gas_deadzone_out ?? "?");
          return `Auto-adjust applied: DZ Out -> ${dzStr}%`;
        }
      }
    };

    /**
     * 2. STATE
     */
    const state = {
      currentTab: 'tab-racing',
      isConnected: false,
      hasData: false,
      activeInterval: 50,
      getCounter: 0,
      frame: {},
      target: { gasP:0, gasL:0, brP:0, brL:0, brRaw:0, brNorm:0, clP:0, clL:0, lagT:0, lagP:0, lagB:0, lagD:0, lagPaint:0 },
      display:{ gasP:0, gasL:0, brP:0, brL:0, brRaw:0, brNorm:0, clP:0, clL:0, lagT:0, lagP:0, lagB:0, lagD:0, lagPaint:0 },
      lagHistory: [],
      pedalHistory: [],
      events: [],
      avgLagT:0, avgLagP:0, avgLagB:0, avgLagD:0, avgLagPaint:0,
      lastProducerPeriod: 100,
      netFailStreak: 0,

      /* Algo-debug visibility + timing helpers */
      lastFetchStartPerf: NaN,
      lastFetchCycleMs: NaN,
      lastTelemetrySequence: NaN,
      lastBatchMeta: null
    };

    // Algo internal state (kept, but reset safely)
    const algoState = {
      integral: 0,
      history: [],
      nextTarget: NaN,
      mode: "ACQUIRE",
      holdBad: 0,
      errLP: 0,
      errInt: 0,
      ewap_ema: 1.0,
      ewap_int: 0,
      qwen_int: 0,
      qwen_dir: 0,
      flowAvg: 1.0
    };

    function resetAlgoState() {
      algoState.integral = 0;
      algoState.history = [];
      algoState.nextTarget = NaN;
      algoState.mode = "ACQUIRE";
      algoState.holdBad = 0;

      algoState.errLP = 0;
      algoState.errInt = 0;

      algoState.ewap_ema = 1.0;
      algoState.ewap_int = 0;

      algoState.qwen_int = 0;
      algoState.qwen_dir = 0;

      algoState.flowAvg = 1.0;
    }

    /**
     * 2.1 ALGO DEBUG SCORING + RING BUFFER (PedDash-generated)
     *
     * - Samples: successful GET responses (one HTTP response == one sample)
     * - Success: FRAMES RX == 1
     * - Accuracy: successes/samples * 100 (3 decimals)
     * - RunTime: seconds since last reset (1 decimal)
     *
     * Resets:
     * - ALGO_MODE change
     * - ENABLE_ALGO_DEBUG toggle
     */
    const ALGO_DEBUG_TELE_KEYS = ['algoSamples', 'algoSuccesses', 'algoAccuracyPct', 'algoRunTimeSec'];

    const algoMetrics = {
      runId: 0,
      algoMode: config.ALGO_MODE,
      startPerf: performance.now(),
      samples: 0,
      successes: 0,

      // Ring buffer
      ring: new Array(config.MAX_HISTORY_LINES),
      ringHead: 0,   // next write index
      ringCount: 0   // number of valid records
    };

    function initAlgoRing(cap) {
      const c = Math.max(50, Math.min(50000, (cap | 0) || 1000));
      algoMetrics.ring = new Array(c);
      algoMetrics.ringHead = 0;
      algoMetrics.ringCount = 0;
    }

    function algoRingToArrayChrono() {
      const cap = algoMetrics.ring?.length || 0;
      const n = Math.min(algoMetrics.ringCount || 0, cap);
      const out = [];
      if (cap <= 0 || n <= 0) return out;

      // Oldest element index
      const start = (algoMetrics.ringHead - n + cap) % cap;
      for (let i = 0; i < n; i++) {
        out.push(algoMetrics.ring[(start + i) % cap]);
      }
      return out;
    }

    function algoRingPush(record) {
      const cap = algoMetrics.ring?.length || 0;
      if (cap <= 0) return;

      algoMetrics.ring[algoMetrics.ringHead] = record;
      algoMetrics.ringHead = (algoMetrics.ringHead + 1) % cap;
      algoMetrics.ringCount = Math.min(cap, (algoMetrics.ringCount || 0) + 1);
    }

    function resizeAlgoRing(newCap) {
      const keep = algoRingToArrayChrono(); // oldest->newest
      initAlgoRing(newCap);

      // Keep most recent up to new cap
      const cap = algoMetrics.ring.length;
      const slice = keep.slice(Math.max(0, keep.length - cap));
      slice.forEach(r => algoRingPush(r));
    }

    function clearAlgoDerivedTelemetry() {
      if (!state.frame) return;
      delete state.frame.algoSamples;
      delete state.frame.algoSuccesses;
      delete state.frame.algoAccuracyPct;
      delete state.frame.algoRunTimeSec;
    }

    function resetAlgoMetrics() {
      algoMetrics.runId++;
      algoMetrics.algoMode = config.ALGO_MODE;
      algoMetrics.startPerf = performance.now();
      algoMetrics.samples = 0;
      algoMetrics.successes = 0;

      // Do not Reset ring to current capacity (matches MAX_HISTORY_LINES)
	  // When changing algorithm, i want to see and compare debug info with other algorithms
      // resizeAlgoRing(config.MAX_HISTORY_LINES);

      // Keep telemetry from going stale on-screen immediately after reset
      if (!state.frame) state.frame = {};
      state.frame.algoSamples = 0;
      state.frame.algoSuccesses = 0;
      state.frame.algoAccuracyPct = 0;
      state.frame.algoRunTimeSec = 0;
    }

    function tickAlgoMetrics(rec, tP, prevSleepMs, nextSleepMs, nextSleepRawMs, nextSleepPostFactorMs, usedSmart, algoCrashMsg) {
      // Stats
      algoMetrics.samples++;
      if (rec === 1) algoMetrics.successes++;

      const runTimeSec = (performance.now() - algoMetrics.startPerf) / 1000;
      const acc = algoMetrics.samples > 0 ? (algoMetrics.successes / algoMetrics.samples) * 100 : 0;

      if (!state.frame) state.frame = {};
      state.frame.algoSamples = algoMetrics.samples;
      state.frame.algoSuccesses = algoMetrics.successes;
      state.frame.algoAccuracyPct = acc;
      state.frame.algoRunTimeSec = runTimeSec;

      // --- CHANGE START: Exit here if the flag is FALSE (skips the heavy logging) ---
      if (!config.ENABLE_ALGO_DEBUG) return;		

      // Build compact per-sample debug record
      const d = new Date();
      const timeStr = d.toLocaleTimeString('en-US',{hour12:false}) + "." + String(d.getMilliseconds()).padStart(3,'0');

      const f = state.frame || {};
      const bm = state.lastBatchMeta || {};

      const servedAt = bm.servedAtUnixMs;
      const oldestEnq = bm.oldestEnqueueUnixMs;
      const newestEnq = bm.newestEnqueueUnixMs;

      const queueAgeOldestMs = (Number.isFinite(servedAt) && Number.isFinite(oldestEnq)) ? (servedAt - oldestEnq) : NaN;
      const queueSpanMs = (Number.isFinite(newestEnq) && Number.isFinite(oldestEnq)) ? (newestEnq - oldestEnq) : NaN;

      const record = {
        timeStr,
        unixMs: Date.now(),
        runId: algoMetrics.runId,
        sampleIdx: algoMetrics.samples,

        algoMode: config.ALGO_MODE,
        smartMode: usedSmart,
        cfgIntervalMs: config.UPDATE_INTERVAL_MS,
        manualFactor: config.MANUAL_UPDATE_FACTOR,
        boundsCheck: config.USE_BOUNDS_CHECK,

        framesRx: rec,
        frameErr: rec - 1,

        tProducerMs: tP,
        prevSleepMs,
        nextSleepRawMs,
        nextSleepPostFactorMs,
        nextSleepMs,

        fetchCycleMs: state.lastFetchCycleMs,
        cycleErrMs: (Number.isFinite(state.lastFetchCycleMs) && Number.isFinite(tP)) ? (state.lastFetchCycleMs - tP) : NaN,

        lagTotalMs: f.lagTotal,
        lagPedMs: f.fullLoopTime_ms,
        lagBrgMs: (Number(f.metricLoopProcessMs || 0) + Number(f.metricHttpProcessMs || 0)),
        lagDashMs: f.lagDash,

        batchId: bm.batchId,
        servedAtUnixMs: bm.servedAtUnixMs,
        oldestEnqueueUnixMs: bm.oldestEnqueueUnixMs,
        newestEnqueueUnixMs: bm.newestEnqueueUnixMs,
        queueAgeOldestMs,
        queueSpanMs,

        telemetrySeq: f.telemetry_sequence,
        seqGap: f.telemetry_sequence_gap,

        // Algo internal snapshots (to help tune PI/PLL style controllers)
        integral: algoState.integral,
        errLP: algoState.errLP,
        errInt: algoState.errInt,
        pllMode: algoState.mode,
        pllHoldBad: algoState.holdBad,
        pllNextTarget: algoState.nextTarget,
        flowAvg: algoState.flowAvg,
        ewapEma: algoState.ewap_ema,
        ewapInt: algoState.ewap_int,
        qwenInt: algoState.qwen_int,

        algoCrash: algoCrashMsg || ""
      };

      algoRingPush(record);
    }

    // UI cache
    let els = {};

    // Canvas contexts (explicit globals so there’s no “window property” ambiguity)
    let ctxGas = null, ctxBrake = null, ctxClutch = null, ctxLag = null, ctxWaveGas = null, ctxWaveClutch = null;

    /**
     * 3. TELEMETRY DEFINITIONS
     */
    const TELE_GROUPS = [
      { title: "Pedal Metrics", keys: ['gas_physical_pct', 'gas_logical_pct', 'brake_physical_pct', 'brake_logical_pct', 'clutch_physical_pct', 'clutch_logical_pct'] },
      { title: "Raw Inputs", keys: ['rawGas', 'gasValue', 'rawBrake', 'brakeValue', 'rawClutch', 'clutchValue', 'axisMax', 'axis_normalization_enabled', 'joy_ID', 'joy_Flags'] },
      { title: "Logic State", keys: ['isRacing', 'peakGasInWindow', 'best_estimate_percent', 'lastFullThrottleTime', 'lastGasActivityTime', 'repeatingClutchCount'] },
      { title: "Pedal Tuning", keys: ['gas_deadzone_in', 'gas_deadzone_out', 'brake_deadzone_in', 'brake_deadzone_out', 'clutch_deadzone_in', 'clutch_deadzone_out', 'gas_min_usage_percent', 'gas_window', 'gas_timeout', 'auto_gas_deadzone_enabled'] },
      { title: "Latency (ms)", keys: ['lagTotal', 'lagPaint', 'producerLagMs', 'queueWaitMs', 'lagDash', 'jsProcessMs', 'activeUpdateInterval', 'fullLoopTime_ms', 'metricLoopProcessMs', 'metricHttpProcessMs', 'metricTtsSpeakMs'] },
      { title: "Event Flags", keys: ['gas_alert_triggered', 'clutch_alert_triggered', 'gas_auto_adjust_applied', 'gas_estimate_decreased', 'controller_disconnected', 'controller_reconnected'] },
      { title: "Diagnostics", keys: ['pedDashGetCount', 'algoMode', 'framesReceivedLastFetch', 'telemetry_sequence', 'batchId', 'deviceReadStartUnixMs', 'deviceReadDurationMs', 'sampleAtUnixMs', 'enqueueAtUnixMs', 'sendAtUnixMs', 'receivedAtUnixMs', 'currentTime', 'pendingFrameCount'] }
    ];

const TELE_DEFS = {
  // --- Pedal Metrics (Producer → UI) ---
  gas_physical_pct:   { label: "Gas Phys %",   short: "gas_physical_pct: Physical travel %", long: "Physical gas travel percent (0–100), computed as 100 * gasValue / axisMax (after optional axis inversion). (Source: FanatecPedals / Producer)" },
  gas_logical_pct:    { label: "Gas Game %",   short: "gas_logical_pct: Deadzone-mapped %", long: "Game-facing gas percent (0–100) after applying deadzone thresholds: 0 below gas_deadzone_in, 100 at/above gas_deadzone_out, linear in between. (Source: FanatecPedals / Producer)" },

  brake_physical_pct: { label: "Brake Phys %", short: "brake_physical_pct: Physical travel %", long: "Physical brake travel percent (0–100), computed as 100 * brakeValue / axisMax (after optional axis inversion). (Source: FanatecPedals / Producer)" },
  brake_logical_pct:  { label: "Brake Game %", short: "brake_logical_pct: Deadzone-mapped %", long: "Game-facing brake percent (0–100) after applying brake deadzone thresholds. (Source: FanatecPedals / Producer)" },

  clutch_physical_pct:{ label: "Clutch Phys %",short: "clutch_physical_pct: Physical travel %", long: "Physical clutch travel percent (0–100), computed as 100 * clutchValue / axisMax (after optional axis inversion). (Source: FanatecPedals / Producer)" },
  clutch_logical_pct: { label: "Clutch Game %",short: "clutch_logical_pct: Deadzone-mapped %", long: "Game-facing clutch percent (0–100) after applying clutch deadzone thresholds. (Source: FanatecPedals / Producer)" },

  // --- Raw Inputs (WinMM) ---
  rawGas:    { label: "Gas Raw",    short: "rawGas: WinMM axis units", long: "Raw gas axis value returned by WinMM joyGetPosEx (units 0..axisMax). (Source: FanatecPedals / Producer)" },
  gasValue:  { label: "Gas Norm",   short: "gasValue: Normalized axis units", long: "Normalized gas axis value used for all logic. If axis_normalization_enabled=1, this is inverted as (axisMax - rawGas) so ‘pressed’ increases value; else equals rawGas. (Source: FanatecPedals / Producer)" },

  rawBrake:  { label: "Brake Raw",  short: "rawBrake: WinMM axis units", long: "Raw brake axis value returned by WinMM joyGetPosEx (units 0..axisMax). (Source: FanatecPedals / Producer)" },
  brakeValue:{ label: "Brake Norm", short: "brakeValue: Normalized axis units", long: "Normalized brake axis value used for all logic. If axis_normalization_enabled=1, this is inverted as (axisMax - rawBrake); else equals rawBrake. (Source: FanatecPedals / Producer)" },

  rawClutch: { label: "Clutch Raw", short: "rawClutch: WinMM axis units", long: "Raw clutch axis value returned by WinMM joyGetPosEx (units 0..axisMax). (Source: FanatecPedals / Producer)" },
  clutchValue:{ label: "Clutch Norm", short: "clutchValue: Normalized axis units", long: "Normalized clutch axis value used for all logic. If axis_normalization_enabled=1, this is inverted as (axisMax - rawClutch); else equals rawClutch. (Source: FanatecPedals / Producer)" },

  axisMax: { label: "Axis Max", short: "axisMax: Axis resolution max", long: "Maximum axis value used for scaling to percent. With JOY_RETURNRAWDATA this is typically 1023; otherwise 65535. May be recomputed on reconnect. (Source: FanatecPedals / Producer)" },
  axis_normalization_enabled: { label: "Norm Flag", short: "axis_normalization_enabled: Invert raw axes?", long: "When 1, producer inverts raw axes (axisMax - raw) to correct devices that report ‘pressed’ as smaller numbers. (Source: FanatecPedals / Producer)" },
  joy_ID:    { label: "Joy ID",    short: "joy_ID: WinMM device index", long: "WinMM joystick ID (device index) currently being polled. (Source: FanatecPedals / Producer)" },
  joy_Flags: { label: "Joy Flags", short: "joy_Flags: joyGetPosEx flags", long: "Bitmask passed to joyGetPosEx controlling which axes are returned and whether raw mode is used (e.g., JOY_RETURNRAWDATA). (Source: FanatecPedals / Producer)" },

  // --- Logic State (Producer) ---
  isRacing: { label: "Is Racing", short: "isRacing: Activity state", long: "Activity state machine: becomes 1 when gasValue rises above idle threshold; returns to 0 after gas_timeout seconds with no gas activity (auto-pause). Used to gate drift/estimation/noise logic. (Source: FanatecPedals / Producer)" },
  peakGasInWindow: { label: "Peak Gas", short: "peakGasInWindow: Peak in window", long: "Highest gasValue observed since the last full-throttle event while isRacing. Used to compute drift percentReached. (Source: FanatecPedals / Producer)" },
  best_estimate_percent: { label: "Best Est %", short: "best_estimate_percent: Suggested DZ-out %", long: "Estimator output for gas_deadzone_out: the smallest qualifying peak-percent observed in estimation windows (>= gas_min_usage_percent). Can be used to suggest or auto-adjust DZ-out. (Source: FanatecPedals / Producer)" },
  lastFullThrottleTime: { label: "Last Full T", short: "lastFullThrottleTime: TickCount ms", long: "Environment.TickCount (ms since boot, wraps ~49 days) when gas last reached full threshold. Used with gas_window to detect drift. (Source: FanatecPedals / Producer)" },
  lastGasActivityTime: { label: "Last Activity", short: "lastGasActivityTime: TickCount ms", long: "TickCount when gas last rose above idle threshold. Used with gas_timeout for auto-pause. (Source: FanatecPedals / Producer)" },
  repeatingClutchCount: { label: "Noise Reps", short: "repeatingClutchCount: Repeat counter", long: "Consecutive-frame counter where clutchValue changes less than axisMargin (while gas idle and clutch is pressed). When it reaches the threshold, clutch_alert_triggered fires. (Source: FanatecPedals / Producer)" },

  // --- Pedal Tuning (Config visible in telemetry) ---
  gas_deadzone_in:  { label: "DZ In %",       short: "gas_deadzone_in: Idle threshold %", long: "Percent of travel treated as idle/0%. Producer converts this to axis units: gasIdleMax = axisMax * gas_deadzone_in / 100. (Source: FanatecPedals / Producer)" },
  gas_deadzone_out: { label: "DZ Out %",      short: "gas_deadzone_out: Full threshold %", long: "Percent of travel treated as full/100%. Producer converts this to axis units: gasFullMin = axisMax * gas_deadzone_out / 100. May change if auto-adjust is enabled. (Source: FanatecPedals / Producer)" },

  brake_deadzone_in:  { label: "Brake DZ In %",  short: "brake_deadzone_in: Idle threshold %", long: "Brake idle deadzone threshold (%). (Source: FanatecPedals / Producer)" },
  brake_deadzone_out: { label: "Brake DZ Out %", short: "brake_deadzone_out: Full threshold %", long: "Brake full deadzone threshold (%). (Source: FanatecPedals / Producer)" },

  clutch_deadzone_in:  { label: "Clutch DZ In %",  short: "clutch_deadzone_in: Idle threshold %", long: "Clutch idle deadzone threshold (%). (Source: FanatecPedals / Producer)" },
  clutch_deadzone_out: { label: "Clutch DZ Out %", short: "clutch_deadzone_out: Full threshold %", long: "Clutch full deadzone threshold (%). (Source: FanatecPedals / Producer)" },

  gas_min_usage_percent: { label: "Min Usage %", short: "gas_min_usage_percent: Qualification %", long: "Minimum % of gas usage required for drift alerts / estimation windows to be considered ‘valid driving’. (Source: FanatecPedals / Producer)" },
  gas_window:  { label: "Gas Window",  short: "gas_window: Seconds", long: "Seconds allowed without reaching full throttle (while isRacing) before a drift alert can fire. (Source: FanatecPedals / Producer)" },
  gas_timeout: { label: "Gas Timeout", short: "gas_timeout: Seconds", long: "Seconds of gas inactivity before isRacing auto-pauses (suppresses alerts/estimation until activity resumes). (Source: FanatecPedals / Producer)" },
  auto_gas_deadzone_enabled: { label: "Auto Adjust", short: "auto_gas_deadzone_enabled: Auto DZ-out", long: "When 1, producer may automatically reduce gas_deadzone_out down toward best_estimate_percent (respecting the configured minimum) and raise gas_auto_adjust_applied. (Source: FanatecPedals / Producer)" },
  // --- Latency & Timing (ms) ---
  lagTotal: { label: "Total Latency", short: "lagTotal: Sample→JS handler ms", long: "End-to-end latency from pedal sample to this JS handler running. Uses per-frame timestamps: sampleAtUnixMs → enqueueAtUnixMs → sendAtUnixMs → Date.now(). (Source: PedDash / UI)" },
  lagPaint: { label: "Sample→Paint", short: "lagPaint: Sample→paint ms", long: "End-to-end latency from pedal sample to the first browser paint after PedDash updates. Computed via requestAnimationFrame using sampleAtUnixMs → Date.now(). (Source: PedDash / UI)" },
  producerLagMs: { label: "Sample→Enqueue", short: "producerLagMs: Producer path ms", long: "Elapsed ms from device sample time (sampleAtUnixMs) until the frame was enqueued for SSE (enqueueAtUnixMs). Captures pedal read + bridge logic before hitting the queue. (Source: PedDash / UI)" },
  queueWaitMs: { label: "Enqueue→Send", short: "queueWaitMs: Queue wait ms", long: "Time a frame sat in the telemetry queue before being written to the SSE stream (sendAtUnixMs − enqueueAtUnixMs). Reveals backlog/FFW impact. (Source: PedDash / UI)" },
  lagDash: { label: "Send→JS Handler", short: "lagDash: Network/buffer ms", long: "Time from when the bridge wrote the SSE event (sendAtUnixMs) until this handler started (Date.now.). Reflects transport, buffering, and JS scheduling before parsing. (Source: PedDash / UI)" },
  jsProcessMs: { label: "JS Proc", short: "jsProcessMs: Parse+UI ms", long: "Time spent in the browser handling the SSE message, including JSON parsing and state/DOM updates, measured from the onmessage entry to after processFrame completes. (Source: PedDash / UI)" },
  fullLoopTime_ms: { label: "Loop Exec", short: "fullLoopTime_ms: Prev loop exec ms", long: "Producer loop execution time in ms for the PREVIOUS iteration (TickCount delta, excludes sleep). One-cycle delayed by design. (Source: FanatecPedals / Producer)" },
  metricLoopProcessMs: { label: "Loop Proc", short: "metricLoopProcessMs: Current loop ms", long: "Producer loop processing time (ms) measured by Stopwatch from loop start until telemetry publish. Includes WinMM poll + logic + enqueue. (Source: FanatecPedals / Producer)" },
  metricHttpProcessMs: { label: "SSE Write", short: "metricHttpProcessMs: Server write ms", long: "Time the FanatecPedals HTTP/SSE server spent serializing + writing the most recent SSE telemetry event to the client (ms). (Source: FanatecPedals / Server)"},
  metricTtsSpeakMs: { label: "TTS Speak", short: "metricTtsSpeakMs: Speak call ms", long: "Time spent in the last Text-To-Speech speak call (ms). 0 when no TTS occurred recently. (Source: FanatecPedals / Producer)" },
  activeUpdateInterval: { label: "Stream Δt", short: "activeUpdateInterval: Observed SSE ms", long: "Observed time between incoming SSE messages (ms), measured in the browser. This is the actual stream cadence, not a configured interval. (Source: PedDash / UI)" },
  deviceReadStartUnixMs: { label: "Read Start", short: "deviceReadStartUnixMs: Read start", long: "Wall-clock ms captured immediately before the WinMM GetPosition call. (Source: FanatecPedals / Producer)" },
  deviceReadDurationMs: { label: "Read Duration", short: "deviceReadDurationMs: Read ms", long: "Duration in ms for the WinMM GetPosition call to return. (Source: FanatecPedals / Producer)" },
  sampleAtUnixMs: { label: "Sample At", short: "sampleAtUnixMs: Pedal timestamp", long: "Wall-clock ms when the pedal sample read started (same as deviceReadStartUnixMs). (Source: FanatecPedals / Producer)" },
  enqueueAtUnixMs: { label: "Enqueue At", short: "enqueueAtUnixMs: Queue timestamp", long: "Wall-clock ms when the telemetry frame was enqueued for SSE delivery. (Source: FanatecPedals / Producer)" },
  sendAtUnixMs: { label: "Send At", short: "sendAtUnixMs: SSE write timestamp", long: "Wall-clock ms captured just before the SSE batch was serialized and written to the client. (Source: PedDash / UI via bridge)" },

  // --- Event Flags ---
  gas_alert_triggered: { label: "Evt: Gas", short: "gas_alert_triggered: Drift alert", long: "Set to 1 on the frame where a gas drift alert is raised (full throttle not reached within gas_window while isRacing). Resets next frame. (Source: FanatecPedals / Producer)" },
  clutch_alert_triggered: { label: "Evt: Clutch", short: "clutch_alert_triggered: Noise alert", long: "Set to 1 on the frame where clutch noise/rudder alert is raised (repeatingClutchCount reached threshold). Resets next frame. (Source: FanatecPedals / Producer)" },
  gas_auto_adjust_applied: { label: "Evt: AutoAdj", short: "gas_auto_adjust_applied: Auto DZ-out", long: "Set to 1 on the frame where gas_deadzone_out was automatically reduced. Resets next frame. (Source: FanatecPedals / Producer)" },
  gas_estimate_decreased: { label: "Evt: EstDec", short: "gas_estimate_decreased: New best est", long: "Set to 1 when best_estimate_percent decreases and is announced (subject to cooldown rules). Resets next frame. (Source: FanatecPedals / Producer)" },
  controller_disconnected: { label: "Evt: Disc", short: "controller_disconnected: Latched state", long: "Latched state: 1 while the device is disconnected. Transition to 1 publishes a frame; cleared on reconnect. (Source: FanatecPedals / Producer)" },
  controller_reconnected: { label: "Evt: Reconn", short: "controller_reconnected: One-shot", long: "One-shot flag: 1 on the reconnect frame, then cleared next frame. (Source: FanatecPedals / Producer)" },

  // --- Diagnostics / Derived ---
  pedDashGetCount: { label: "Msg Count", short: "pedDashGetCount: SSE messages", long: "Total SSE telemetry messages received since page load. (Source: PedDash / UI)" },
  algoMode: { label: "Algo Mode", short: "algoMode: Selected strategy", long: "Selected PedDash strategy (ALGO_MODE). In SSE push mode it does not control the stream; it’s used for scoring/visualization and legacy math paths. (Source: PedDash / UI)" },
  framesReceivedLastFetch: { label: "Frames Rx", short: "framesReceivedLastFetch: Burst size", long: "Number of producer frames coalesced into the latest SSE message (burst size). Drives FRAMES RX and the FFW indicator when >1. (Source: PedDash / UI + Server metadata)" },
  pendingFrameCount: { label: "Coalesced", short: "pendingFrameCount: Alias of burst size", long: "In SSE mode this is intentionally set equal to the burst size (same as FRAMES RX) for backwards compatibility. It is NOT the live queue depth. (Source: PedDash / UI)" },

  telemetry_sequence: { label: "Seq ID", short: "telemetry_sequence: Producer frame id", long: "Monotonic producer sequence number incremented per produced telemetry frame. Useful for detecting drops (seq gaps). (Source: FanatecPedals / Producer)" },
  batchId: { label: "Batch ID", short: "batchId: SSE message id", long: "Monotonic server batch/message id incremented per SSE event sent to the client. (Source: FanatecPedals / Server)" },
  receivedAtUnixMs: { label: "ServedAt", short: "receivedAtUnixMs: Wall-clock ms", long: "Wall-clock timestamp (ms since epoch) used by PedDash for lag math. In SSE mode, PedDash overwrites receivedAtUnixMs to the server servedAtUnixMs for backwards compatibility. (Source: FanatecPedals / Server + PedDash / UI)" },
  currentTime: { label: "TickCount", short: "currentTime: TickCount ms", long: "Environment.TickCount at capture time (ms since boot; wraps ~49 days). Used by producer logic for windows/timeouts. (Source: FanatecPedals / Producer)" },

  /* --- PedDash-generated algorithm scoring metrics (shown only when ENABLE_ALGO_DEBUG is checked) --- */
  algoSamples: { label: "Algo Samples", short: "algoSamples: Telemetry updates", long: "Count of telemetry updates processed for the current algo run (SSE messages). Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash / UI)" },
  algoSuccesses: { label: "Algo Successes", short: "algoSuccesses: FRAMES RX == 1", long: "Number of samples where FRAMES RX was exactly 1 (one producer frame per SSE message) for the current algo run. Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash / UI)" },
  algoAccuracyPct: { label: "Algo Accuracy %", short: "algoAccuracyPct: Success rate", long: "Percent of samples where FRAMES RX == 1. Range 0–100 with 3 decimals. Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash / UI)" },
  algoRunTimeSec: { label: "Algo Run Time", short: "algoRunTimeSec: Seconds", long: "Seconds the current algo run has been active since last reset (ALGO_MODE change or ENABLE_ALGO_DEBUG toggle). (Source: PedDash / UI)" }
};

	  
/* old
	const TELE_DEFS = {
      gas_physical_pct: { label: "Gas Phys %", short: "gas_physical_pct: Raw Input", long: "Raw percentage of gas pedal physical travel. (Source: PedMon)" },
      gas_logical_pct:  { label: "Gas Game %",  short: "gas_logical_pct: Game Value", long: "Final gas value sent to the game after deadzones and logic. (Source: PedMon)" },
      brake_physical_pct: { label: "Brake Phys %", short: "brake_physical_pct: Raw Input", long: "Raw percentage of brake pedal physical travel. (Source: PedMon)" },
      brake_logical_pct:  { label: "Brake Game %",  short: "brake_logical_pct: Game Value", long: "Final brake value sent to the game after processing. (Source: PedMon)" },
      clutch_physical_pct: { label: "Clutch Phys %", short: "clutch_physical_pct: Raw Input", long: "Raw percentage of clutch physical travel. (Source: PedMon)" },
      clutch_logical_pct:  { label: "Clutch Game %",  short: "clutch_logical_pct: Game Value", long: "Final clutch value sent to the game after processing. (Source: PedMon)" },

      rawGas: { label: "Gas Raw", short: "rawGas: Hardware units", long: "Direct value from joyGetPosEx. (Source: PedMon)" },
      gasValue: { label: "Gas Norm", short: "gasValue: Normalized units", long: "Hardware value after inversion correction. (Source: PedMon)" },
      rawBrake: { label: "Brake Raw", short: "rawBrake: Hardware units", long: "Direct value from JoyAPI. (Source: PedMon)" },
      brakeValue: { label: "Brake Norm", short: "brakeValue: Normalized units", long: "Hardware value after inversion. (Source: PedMon)" },
      rawClutch: { label: "Clutch Raw", short: "rawClutch: Hardware units", long: "Direct value from JoyAPI. (Source: PedMon)" },
      clutchValue: { label: "Clutch Norm", short: "clutchValue: Normalized units", long: "Hardware value after inversion. (Source: PedMon)" },
      axisMax: { label: "Axis Max", short: "axisMax: Scale", long: "The maximum range of the joystick axis. (Source: PedMon)" },
      axis_normalization_enabled: { label: "Norm Flag", short: "axis_normalization_enabled: Boolean flag", long: "If 1, PedMon mirrors inverted hardware signals. (Source: PedMon)" },
      joy_ID: { label: "Joy ID", short: "joy_ID: Integer ID", long: "Windows Joystick ID currently monitored. (Source: PedMon)" },
      joy_Flags: { label: "Joy Flags", short: "joy_Flags: Bitmask", long: "WinMM flags used for capturing data. (Source: PedMon)" },

      isRacing: { label: "Is Racing", short: "isRacing: Boolean flag", long: "Indicates if the user is currently driving. (Source: PedMon)" },
      peakGasInWindow: { label: "Peak Gas", short: "peakGasInWindow: Max", long: "Highest gas value reached in current window. (Source: PedMon)" },
      best_estimate_percent: { label: "Best Est %", short: "best_estimate_percent: Estimate", long: "Suggested ideal deadzone for pedal health. (Source: PedMon)" },
      lastFullThrottleTime: { label: "Last Full T", short: "lastFullThrottleTime: TickCount", long: "TickCount when full throttle was last hit. (Source: PedMon)" },
      lastGasActivityTime: { label: "Last Activity", short: "lastGasActivityTime: TickCount", long: "TickCount of last pedal movement. (Source: PedMon)" },
      repeatingClutchCount: { label: "Noise Reps", short: "repeatingClutchCount: Count", long: "Sequential frames of noise detected. (Source: PedMon)" },

      gas_deadzone_in: { label: "DZ In %", short: "gas_deadzone_in: Percent", long: "Percentage of travel treated as idle. (Source: PedMon)" },
      gas_deadzone_out: { label: "DZ Out %", short: "gas_deadzone_out: Percent", long: "Percentage of travel treated as 100%. (Source: PedMon)" },
      brake_deadzone_in: { label: "Brake DZ In %", short: "brake_deadzone_in: Percent", long: "Brake pedal idle deadzone percentage. (Source: PedMon)" },
      brake_deadzone_out: { label: "Brake DZ Out %", short: "brake_deadzone_out: Percent", long: "Brake pedal full-travel threshold percentage. (Source: PedMon)" },
      clutch_deadzone_in: { label: "Clutch DZ In %", short: "clutch_deadzone_in: Percent", long: "Clutch pedal idle deadzone percentage. (Source: PedMon)" },
      clutch_deadzone_out: { label: "Clutch DZ Out %", short: "clutch_deadzone_out: Percent", long: "Clutch pedal full-travel threshold percentage. (Source: PedMon)" },
      gas_min_usage_percent: { label: "Min Usage %", short: "gas_min_usage_percent: Percent", long: "Min travel needed to validate drift checks. (Source: PedMon)" },
      gas_window: { label: "Gas Window", short: "gas_window: Seconds", long: "Duration checked for full throttle events. (Source: PedMon)" },
      gas_timeout: { label: "Gas Timeout", short: "gas_timeout: Seconds", long: "Seconds of idle before assuming paused. (Source: PedMon)" },
      auto_gas_deadzone_enabled: { label: "Auto Adjust", short: "auto_gas_deadzone_enabled: Boolean", long: "If 1, PedMon lowers DZ Out automatically. (Source: PedMon)" },

      lagTotal: { label: "Total Latency", short: "lagTotal: Total pipeline ms", long: "Total time across C (PedMon), PS (PedBridge), and JS (PedDash). (Source: PedDash)" },
      fullLoopTime_ms: { label: "C Loop", short: "fullLoopTime_ms: PedMon ms", long: "Processing time of the C monitor loop. (Source: PedMon)" },
      metricLoopProcessMs: { label: "PS Loop", short: "metricLoopProcessMs: PedBridge loop ms", long: "Time PowerShell took to process the shared-memory loop iteration. (Source: PedBridge)" },
      metricHttpProcessMs: { label: "PS HTTP", short: "metricHttpProcessMs: Serve ms", long: "Time PedBridge spent packaging/writing the most recent telemetry message (ms). (Source: PedBridge)" },
      metricTtsSpeakMs: { label: "PS TTS", short: "metricTtsSpeakMs: TTS call ms", long: "Time spent in the PedBridge TTS speak call path for the most recent utterance (ms). (Source: PedBridge)" },
      lagDash: { label: "JS Render", short: "lagDash: Bridge→UI ms", long: "Time from PedBridge 'servedAtUnixMs' to when this UI handler runs (ms). (Source: PedDash)" },
      activeUpdateInterval: { label: "Stream Δt", short: "activeUpdateInterval: Observed ms", long: "Observed time between incoming SSE messages (ms). (Source: PedDash)" },

      gas_alert_triggered: { label: "Evt: Gas", short: "gas_alert_triggered: Flag", long: "Fired when gas drift is detected. (Source: PedMon)" },
      clutch_alert_triggered: { label: "Evt: Clutch", short: "clutch_alert_triggered: Flag", long: "Fired when rudder noise is detected. (Source: PedMon)" },
      gas_auto_adjust_applied: { label: "Evt: AutoAdj", short: "gas_auto_adjust_applied: Flag", long: "Fired when deadzone was adjusted. (Source: PedMon)" },
      gas_estimate_decreased: { label: "Evt: EstDec", short: "gas_estimate_decreased: Flag", long: "Fired on new estimation discovery. (Source: PedMon)" },
      controller_disconnected: { label: "Evt: Disc", short: "controller_disconnected: Flag", long: "Fired when pedal device is lost. (Source: PedMon)" },
      controller_reconnected: { label: "Evt: Reconn", short: "controller_reconnected: Flag", long: "Fired when device is re-found. (Source: PedMon)" },

      pedDashGetCount: { label: "Msg Count", short: "pedDashGetCount: SSE messages", long: "Total SSE messages received since page load. (Source: PedDash)" },
      algoMode: { label: "Algo Mode", short: "algoMode: Selected algorithm", long: "The currently selected Smart Algorithm (ALGO_MODE). (Source: PedDash)" },
      framesReceivedLastFetch: { label: "Frames Rx", short: "framesReceivedLastFetch: FRAMES RX", long: "Number of telemetry frames delivered in the last HTTP response batch. (Source: PedDash)" },
      pendingFrameCount: { label: "Pending", short: "pendingFrameCount: Queue depth", long: "Frames waiting in PedBridge queue at the moment the HTTP request was served. (Source: PedBridge)" },
      telemetry_sequence: { label: "Seq ID", short: "telemetry_sequence: Producer sequence", long: "Increments per PedMon produced frame. (Source: PedMon)" },
      batchId: { label: "Batch ID", short: "batchId: PedBridge batch", long: "Increments per PedBridge HTTP response. (Source: PedBridge)" },
      receivedAtUnixMs: { label: "Bridge Served", short: "receivedAtUnixMs: Served time", long: "Time PedBridge served the HTTP response (ms since epoch). (Source: PedBridge)" },
      currentTime: { label: "C Current", short: "currentTime: TickCount", long: "Windows TickCount at capture. (Source: PedMon)" },

      // --- PedDash-generated algorithm scoring metrics (shown only when ENABLE_ALGO_DEBUG is checked) --- 
      algoSamples: { label: "Algo Samples", short: "algoSamples: GET samples", long: "Count of successful HTTP GET responses for the current algo run. One GET response == one sample (regardless of FRAMES RX). Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash)" },
      algoSuccesses: { label: "Algo Successes", short: "algoSuccesses: FRAMES RX == 1", long: "Number of samples where framesReceivedLastFetch (FRAMES RX) was exactly 1 for the current algo run. Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash)" },
      algoAccuracyPct: { label: "Algo Accuracy %", short: "algoAccuracyPct: Success rate", long: "Percent of samples where framesReceivedLastFetch (FRAMES RX) == 1. Range 0–100 with 3 decimals. Resets on ALGO_MODE change or ENABLE_ALGO_DEBUG toggle. (Source: PedDash)" },
      algoRunTimeSec: { label: "Algo Run Time", short: "algoRunTimeSec: Seconds", long: "Seconds the current algorithm has been running since last reset (ALGO_MODE change or ENABLE_ALGO_DEBUG toggle). Displayed with 1 decimal place. (Source: PedDash)" }
    }; */

    /**
     * 4. STRATEGIES
     */
    const AlgorithmStrategies = {
      "FRAME_LOCK": (rec, tP, current) => {
        const cruise = tP + 5;
        if (rec === 0) return tP;
        if (rec > 1) return 10;
        return cruise;
      },
      "SMOOTH_CONVERGENCE": (rec, tP, current) => {
        if (rec === 0) return Math.min(current * 1.1, tP * 1.5);
        if (rec === 1) return (current * 0.9) + (tP * 0.1);
        return current * 0.85;
      },
      "ALGO_DIGITAL_PLL": (rec, tP, current) => {
        const now = performance.now();
        if (!Number.isFinite(algoState.nextTarget)) algoState.nextTarget = now;

        // Queue-depth phase detector:
        // rec==0 => too early (positive error), rec==1 => ok, rec>1 => too late (negative error)
        let e = (rec <= 0) ? 1 : (rec === 1 ? 0 : -(rec - 1));

        // Loop filter (low-pass + integral)
        algoState.errLP += 0.25 * (e - algoState.errLP);
        algoState.errInt = Math.max(-8, Math.min(8, algoState.errInt + algoState.errLP));

        let adjust = (6.0 * algoState.errLP) + (0.6 * algoState.errInt);

        // Acquire/Hold gating (slightly conservative for jittery browsers)
        if (algoState.mode === "ACQUIRE") {
          if (rec === 1) adjust -= 0.25;
          if (rec <= 0) {
            adjust += 5;
            algoState.mode = "HOLD";
            algoState.holdBad = 0;
            algoState.errLP = 0;
            algoState.errInt = 0;
          }
        } else {
          if (rec !== 1) {
            if (++algoState.holdBad >= 2) {
              algoState.mode = "ACQUIRE";
              algoState.holdBad = 0;
              algoState.errInt *= 0.5;
            }
          } else {
            algoState.holdBad = 0;
          }
        }

        adjust = Math.max(-25, Math.min(25, adjust));

        // Step near producer period
        const step = Math.max(tP * 0.6, Math.min(tP * 1.4, tP + adjust));
        algoState.nextTarget += step;

        // If we fell behind, jump forward by whole steps
        if (algoState.nextTarget < now + 2) {
          const def = (now + 2) - algoState.nextTarget;
          algoState.nextTarget += Math.ceil(def / step) * step;
        }

        return Math.max(0, algoState.nextTarget - now);
      },
      "ALGO_INTEGRAL_FLOW": (rec, tP, current) => {
        algoState.flowAvg = (0.2 * rec) + 0.8 * algoState.flowAvg;
        return current - ((algoState.flowAvg - 1.0) * 2.0);
      },
      "ALGO_GROK_PI": (rec, tP, current) => {
        const err = 1 - rec;
        algoState.integral = Math.max(-200, Math.min(200, algoState.integral + err));
        return current + (10 * err) + (0.05 * algoState.integral);
      },
      "ALGO_DEEPSEEK_PI": (rec, tP, current) => {
        const err = 1.0 - rec;
        algoState.history.push(err);
        if (algoState.history.length > 5) algoState.history.shift();

        const smErr = algoState.history.reduce((a,b)=>a+b,0) / algoState.history.length;
        algoState.integral = Math.max(-200, Math.min(200, algoState.integral + smErr * 50));
        return (0.7 * current) + 0.3 * (tP + (15 * smErr) + (0.3 * algoState.integral));
      },
      "ALGO_QWEN_HYSTERESIS": (rec, tP, current) => {
        if (rec === 0) return Math.min(200, current * 1.15);
        const pErr = rec - 1;
        const adj = 8 * pErr;
        algoState.qwen_int = Math.max(-tP, Math.min(tP, algoState.qwen_int + pErr));
        return current - (adj + 0.05 * algoState.qwen_int);
      },
      "ALGO_CLAUDE_EWAP": (rec, tP, current) => {
        algoState.ewap_ema = (0.3 * rec) + 0.7 * algoState.ewap_ema;
        const err = algoState.ewap_ema - 1.0;
        algoState.ewap_int = Math.max(-20, Math.min(20, algoState.ewap_int + err));

        let corr = (0.15 * err) + (0.02 * algoState.ewap_int);
        if (rec === 0 && algoState.ewap_ema < 0.5) corr = Math.min(corr, -0.05);
        if (rec >= 3) corr = Math.max(corr, 0.2);

        return current - (corr * tP);
      },
      "ALGO_LEGACY": (rec, tP, current) => {
        if (rec === 1) return tP;
        if (rec > 1) return current * (1 / rec);
        return tP;
      }
    };

    /**
     * 5. UTILS
     */
    /* function safeSetText(el, text) { if (el) el.textContent = text; } */
	/* Optimization */
	function safeSetText(el, text) { 
	      // Only write to the DOM if the value actually changed
	      if (el && el.textContent !== text) {
	        el.textContent = text; 
	      }
	    }	  

    // FIXED: pushHistory was missing (primary crash)
    function pushHistory(arr, item, limit = MAX_CHART_HISTORY) {
      if (!Array.isArray(arr)) return;
      arr.push(item);
      if (arr.length > limit) {
        arr.splice(0, arr.length - limit);
      }
    }

    function switchTab(id) {
      state.currentTab = id;
      document.querySelectorAll('.tab-btn').forEach(b => {
        const btnId = 'btn-' + id.split('-')[1];
        b.classList.toggle('active', b.id === btnId);
      });
      document.querySelectorAll('.tab-content').forEach(t => t.classList.toggle('active', t.id === id));
    }

    function updateConfig(k, v) {
      if (!(k in config)) return;

      const prev = config[k];
      let next = v;

      if (typeof prev === 'number') next = Number.parseFloat(v);
      if (typeof prev === 'boolean') next = Boolean(v);

      if (Number.isNaN(next) && typeof prev === 'number') next = prev;

      config[k] = next;

      if (k === 'MAX_HISTORY_LINES') {
        config.MAX_HISTORY_LINES = Math.max(50, Math.min(50000, (config.MAX_HISTORY_LINES | 0) || 1000));

        // Keep events bounded
        if (state.events.length > config.MAX_HISTORY_LINES) {
          state.events.splice(config.MAX_HISTORY_LINES);
        }

        // Ring buffer size must match history lines
        resizeAlgoRing(config.MAX_HISTORY_LINES);
      }

      if (k === 'ALGO_MODE') {
        logEvent("System", `Algo: ${config.ALGO_MODE}`);
        resetAlgoState();

        // Reset scoring + debug records (requested)
        resetAlgoMetrics();
      }

      if (k === 'ENABLE_ALGO_DEBUG') {
        // Reset on toggle (requested)
        resetAlgoMetrics();

        // Rebuild Data Map so Diagnostics conditionally shows/hides scoring metrics
        initTelemetryUI();

        // If disabled, keep derived telemetry from going stale in UI
        if (!config.ENABLE_ALGO_DEBUG) clearAlgoDerivedTelemetry();
      }

      initConfigControls();
    }

    function toggleChip(el, act, cls) { if (el) el.classList.toggle(cls, Boolean(act)); }

    function resizeCanvas(c) {
      if (!c) return;
      const r = c.parentElement.getBoundingClientRect();
      const h = r.height - (c.previousElementSibling ? 30 : 0);
      if (c.width !== r.width || c.height !== h) { c.width = r.width; c.height = h; }
    }

    function calcAverages() {
      const count = Math.max(1, Math.floor((AVG_WINDOW_S * 1000) / (state.activeInterval || 50)));
      if (state.lagHistory.length === 0) return;
      const recent = state.lagHistory.slice(-count);
      const len = recent.length;
      state.avgLagT = recent.reduce((s,i) => s + i.total, 0) / len;
      state.avgLagP = recent.reduce((s,i) => s + i.ped, 0) / len;
      state.avgLagB = recent.reduce((s,i) => s + i.brg, 0) / len;
      state.avgLagD = recent.reduce((s,i) => s + i.dash, 0) / len;
      const paint = recent.reduce((s,i) => {
        if (!Number.isFinite(i.paint)) return s;
        return { sum: s.sum + i.paint, count: s.count + 1 };
      }, { sum: 0, count: 0 });
      state.avgLagPaint = paint.count ? (paint.sum / paint.count) : 0;
    }

    function logEvent(t, m) {
      if (state.events.length > 0 && state.events[0].msg === m && (Date.now() - state.events[0].ts) < 2000) return;

      const d = new Date();
      const ts = d.toLocaleTimeString('en-US',{hour12:false}) + "." + String(d.getMilliseconds()).padStart(3,'0');
      const e = { ts: Date.now(), timeStr: ts, type: t, msg: m };

      state.events.unshift(e);
      if (state.events.length > config.MAX_HISTORY_LINES) state.events.pop();

      // Ticker (newest-first)
      if (els.tickerList) {
        const item = document.createElement('div');
        item.className = 'ticker-item';
        item.innerHTML = `<span class="ticker-time">${ts}</span><span>${t}: ${m}</span>`;
        els.tickerList.prepend(item);
        if (els.tickerList.children.length > 5) els.tickerList.lastElementChild.remove();
      }

      // Full event table (newest-first)
      if (els.fullEventList) {
        const row = document.createElement('div');
        row.className = 'event-row';
        let c = '#fff';
        if (t === 'Alert') c = 'var(--neon-red)';
        if (t === 'Warn')  c = 'var(--neon-amber)';

        // 4th column left blank (matches header grid)
        row.innerHTML = `<div>${ts}</div><div style="color:${c}">${t}</div><div>${m}</div><div></div>`;
        els.fullEventList.prepend(row);
        if (els.fullEventList.children.length > 200) els.fullEventList.lastElementChild.remove();
      }
    }

    function csvEscape(val) {
      const s = String(val ?? "");
      return /[",\n]/.test(s) ? `"${s.replaceAll('"', '""')}"` : s;
    }

    function exportLogs() {
      const header = "Time,Type,Message\n";
      const rows = state.events.map(e => `${csvEscape(e.timeStr)},${csvEscape(e.type)},${csvEscape(e.msg)}`).join("\n");
      const csv = header + rows;
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('href', url);
      a.setAttribute('download', 'peddash_logs.csv');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    function exportAlgoDebugCsv() {
      const rows = algoRingToArrayChrono();

      const cols = [
        ["Time", r => r.timeStr],
        ["UnixMs", r => r.unixMs],
        ["RunId", r => r.runId],
        ["Sample", r => r.sampleIdx],

        ["AlgoMode", r => r.algoMode],
        ["SmartMode", r => r.smartMode],
        ["CfgIntervalMs", r => r.cfgIntervalMs],
        ["ManualFactor", r => r.manualFactor],
        ["BoundsCheck", r => r.boundsCheck],

        ["FramesRx", r => r.framesRx],
        ["FrameErr", r => r.frameErr],
        ["tP_ms", r => r.tProducerMs],

        ["PrevSleep_ms", r => r.prevSleepMs],
        ["NextSleepRaw_ms", r => r.nextSleepRawMs],
        ["NextSleepPostFactor_ms", r => r.nextSleepPostFactorMs],
        ["NextSleep_ms", r => r.nextSleepMs],

        ["FetchCycle_ms", r => r.fetchCycleMs],
        ["CycleErr_ms", r => r.cycleErrMs],

        ["LagTotal_ms", r => r.lagTotalMs],
        ["LagPed_ms", r => r.lagPedMs],
        ["LagBrg_ms", r => r.lagBrgMs],
        ["LagDash_ms", r => r.lagDashMs],

        ["BatchId", r => r.batchId],
        ["ServedAtUnixMs", r => r.servedAtUnixMs],
        ["OldestEnqueueUnixMs", r => r.oldestEnqueueUnixMs],
        ["NewestEnqueueUnixMs", r => r.newestEnqueueUnixMs],
        ["QueueAgeOldest_ms", r => r.queueAgeOldestMs],
        ["QueueSpan_ms", r => r.queueSpanMs],

        ["TelemetrySeq", r => r.telemetrySeq],
        ["SeqGap", r => r.seqGap],

        ["AlgoIntegral", r => r.integral],
        ["AlgoErrLP", r => r.errLP],
        ["AlgoErrInt", r => r.errInt],
        ["PLL_Mode", r => r.pllMode],
        ["PLL_HoldBad", r => r.pllHoldBad],
        ["PLL_NextTarget", r => r.pllNextTarget],
        ["FlowAvg", r => r.flowAvg],
        ["EWAP_EMA", r => r.ewapEma],
        ["EWAP_Int", r => r.ewapInt],
        ["QwenInt", r => r.qwenInt],

        ["AlgoCrash", r => r.algoCrash]
      ];

      const header = cols.map(c => csvEscape(c[0])).join(",") + "\n";
      const body = rows.map(r => cols.map(c => csvEscape(c[1](r))).join(",")).join("\n");
      const csv = header + body;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('href', url);
      a.setAttribute('download', `peddash_algo_debug_run${algoMetrics.runId}.csv`);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }


// Optimizatin: create cached gradient
const cachedGrad = (function() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const grad = ctx.createLinearGradient(0, 0, 300, 0); // Match canvas width
  grad.addColorStop(0, '#00f3ff');
  grad.addColorStop(1, '#0088aa');
  return grad;
})();

    /**
     * 6. DRAWING
     */
    function drawDualGauge(ctx, label, phys, log) {
      if (!ctx) return;
      const w = ctx.canvas.width, h = ctx.canvas.height, cx = w/2, cy = h/2, rO = (w/2)-15, rI = rO-30;
      ctx.clearRect(0,0,w,h);
      ctx.lineCap = 'round';
      ctx.lineWidth = 20;
      ctx.strokeStyle = '#222';
      ctx.beginPath(); ctx.arc(cx,cy,rO,0.75*Math.PI,2.25*Math.PI); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx,cy,rI,0.75*Math.PI,2.25*Math.PI); ctx.stroke();

      const pA = 0.75*Math.PI + (1.5*Math.PI*(Math.max(0, Math.min(100, phys))/100));
      const grad = ctx.createLinearGradient(0,0,w,0);
      grad.addColorStop(0,'#00f3ff');
      grad.addColorStop(1,'#0088aa');
      
	  // Optimization, use a cached gradient
	  // ctx.strokeStyle = phys>0 ? grad : '#222';
	  ctx.strokeStyle = phys > 0 ? cachedGrad : '#222'; // Use cached
      if (phys > 0) { ctx.beginPath(); ctx.arc(cx,cy,rO,0.75*Math.PI,pA); ctx.stroke(); }

      const lA = 0.75*Math.PI + (1.5*Math.PI*(Math.max(0, Math.min(100, log))/100));
      const color = (log===0) ? '#fff' : (log>=99 ? '#ff3333' : '#39ff14');

		
      ctx.strokeStyle = color;
	// --- OPTIMIZATION: COMMENT OUT THESE 2 LINES ---
	// ctx.shadowBlur = 15;
	// ctx.shadowColor = color;
	// -----------------------------------------------
		
      ctx.beginPath(); ctx.arc(cx,cy,rI,0.75*Math.PI,lA); ctx.stroke();

	// --- OPTIMIZATION: COMMENT OUT THESE 1 LINE ---		
	// ctx.shadowBlur = 0; // Remove this too if you removed the lines above

      ctx.fillStyle = color;
      ctx.font = "bold 80px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(Math.round(log), cx, cy);

      ctx.fillStyle = "#777";
      ctx.font = "bold 32px sans-serif";
      ctx.fillText(label, cx, cy+60);
    }

    function drawHistoryChart(ctx, data, keys, colors, min, max, multi) {
      if (!ctx || !data || data.length < 2) return;

      let mi = (min !== null ? min : 0);
      let ma = max;

      if (ma === null) {
        ma = 0;
        data.forEach(d => keys.forEach(k => { if ((d[k] ?? 0) > ma) ma = d[k]; }));
        ma = Math.max(ma, 10) * 1.1;
      }

      const w = ctx.canvas.width, h = ctx.canvas.height, pL=40, pR=10, pT=10, pB=30;
      const mX = (i)=>pL+(i/(MAX_CHART_HISTORY-1))*(w-pL-pR);
      const mY = (v)=>h-pB-((v-mi)/(ma-mi))*(h-pT-pB);

      ctx.clearRect(0,0,w,h);

      // Grid
      ctx.strokeStyle='#222'; ctx.lineWidth=1; ctx.fillStyle='#555';
      ctx.font='12px monospace'; ctx.textAlign='right';
      for (let i=0;i<=4;i++){
        const v = mi+(ma-mi)*(i/4);
        const y = mY(v);
        ctx.beginPath(); ctx.moveTo(pL,y); ctx.lineTo(w-pR,y); ctx.stroke();
        ctx.fillText(v.toFixed(0), pL-5, y+4);
      }

      // X labels
      ctx.textAlign='center';
      for (let i=0;i<5;i++){
        const x = mX((MAX_CHART_HISTORY-1)*(i/4));
        const s = ((MAX_CHART_HISTORY*(state.activeInterval||50))/1000) * (1-(i/4));
        ctx.fillText(s===0 ? "Now" : `-${s.toFixed(0)}s`, x, h-8);
        ctx.beginPath(); ctx.moveTo(x,h-pB); ctx.lineTo(x,h-pB+5); ctx.stroke();
      }

      // Lines
      keys.forEach((k,idx)=>{
        ctx.beginPath();
        ctx.strokeStyle = colors[idx];
        ctx.lineWidth = 2;
        ctx.shadowBlur = multi ? 0 : 4;
        ctx.shadowColor = colors[idx];

        data.forEach((d,i)=>{
          const x = mX(i);
          const y = mY(d[k] ?? 0);
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });

        ctx.stroke();
      });
      ctx.shadowBlur = 0;
    }

    /**
     * 7. DATA STREAM (SSE)
     * Replaces polling fetch() with one persistent connection:
     * - latest-wins semantics are enforced by PedBridge (bounded buffer + drop-oldest)
     * - we receive 1 "latest" frame per message, plus pendingFrameCount telling us how many were coalesced
     * - only ONE dashboard is allowed; additional dashboards get an SSE "busy" event
     */
    let evtSource = null;
    let reconnectTimer = null;
    let sseBackoffMs = 500;
    let sseHardDisabled = false; // set true when we receive "busy"

    function startTelemetryStream() {
      if (sseHardDisabled) return;

      // Ensure we never have two EventSource objects
      try { if (evtSource) evtSource.close(); } catch {}
      evtSource = null;

      if (reconnectTimer) clearTimeout(reconnectTimer);
      reconnectTimer = null;

      logEvent("System", `Connecting SSE: ${BRIDGE_URL}`);

      evtSource = new EventSource(BRIDGE_URL);

      evtSource.onopen = () => {
        state.isConnected = true;
        state.netFailStreak = 0;
        sseBackoffMs = 500;

        if (!state.hasData) {
          logEvent("System", "Bridge Connected (SSE).");
          state.hasData = true;
        }
      };

      // If a second dashboard tries to connect, PedBridge sends event: busy then closes.
      evtSource.addEventListener("busy", (e) => {
        sseHardDisabled = true;
        state.isConnected = false;

        let msg = "SSE busy: another dashboard is already connected. Close it and refresh this page.";
        try {
          const obj = JSON.parse(e.data);
          if (obj?.detail) msg = obj.detail;
        } catch {}
        logEvent("Error", msg);

        try { evtSource.close(); } catch {}
        evtSource = null;
      });

      evtSource.onmessage = (e) => {
        const handlerStartPerf = performance.now();
        const handlerStartWall = Date.now();
        const nowPerf = performance.now();

        // Observed cadence (time between SSE messages)
        if (Number.isFinite(state.lastFetchStartPerf)) {
          state.lastFetchCycleMs = nowPerf - state.lastFetchStartPerf;
          state.activeInterval = state.lastFetchCycleMs; // re-use the field to mean "observed Δt"
        } else {
          state.lastFetchCycleMs = NaN;
          state.activeInterval = NaN;
        }
        state.lastFetchStartPerf = nowPerf;

        let json;
        try {
          json = JSON.parse(e.data);
        } catch (err) {
          logEvent("Warn", "Bad SSE JSON frame");
          return;
        }

        state.getCounter++;

        const frames = json?.frames || [];
        const bi = json?.bridgeInfo || {};

        // Store batch-level metadata for algo-debug export (still useful in SSE mode)
        if (frames.length > 0) {
          const newest = frames[frames.length - 1];
          const oldest = frames[0];
          const newestEnqueue = Number(newest.enqueueAtUnixMs ?? newest.bridgeEnqueueAtUnixMs ?? newest.receivedAtUnixMs);
          const oldestEnqueue = Number(oldest.enqueueAtUnixMs ?? oldest.bridgeEnqueueAtUnixMs ?? oldest.receivedAtUnixMs);
          state.lastBatchMeta = {
            batchId: bi.batchId ?? newest.batchId ?? null,
            servedAtUnixMs: bi.servedAtUnixMs ?? newest.sendAtUnixMs ?? null,
            framesInBatch: frames.length,
            pendingFrameCount: bi.pendingFrameCount ?? frames.length,
            oldestEnqueueUnixMs: Number.isFinite(oldestEnqueue) ? oldestEnqueue : null,
            newestEnqueueUnixMs: Number.isFinite(newestEnqueue) ? newestEnqueue : null
          };
        } else {
          state.lastBatchMeta = {
            batchId: bi.batchId ?? null,
            servedAtUnixMs: bi.servedAtUnixMs ?? null,
            framesInBatch: 0,
            pendingFrameCount: bi.pendingFrameCount ?? 0,
            oldestEnqueueUnixMs: null,
            newestEnqueueUnixMs: null
          };
          return;
        }

        const latest = frames[frames.length - 1];

        // In SSE mode, we interpret pendingFrameCount as "how many frames were coalesced since last message"
        const coalesced = bi.pendingFrameCount ?? frames.length;
        latest.framesReceivedLastFetch = coalesced;   // powers your FRAMES RX + red warning + ffw indicator
        latest.pendingFrameCount = coalesced;         // keep existing diagnostics card meaningful
        latest.batchId = bi.batchId ?? latest.batchId;

        const enqueueAt = Number(latest.enqueueAtUnixMs ?? latest.bridgeEnqueueAtUnixMs ?? latest.receivedAtUnixMs);
        const sendAt = Number(latest.sendAtUnixMs ?? bi.servedAtUnixMs ?? latest.bridgeServedAtUnixMs ?? latest.receivedAtUnixMs);

        latest.bridgeEnqueueAtUnixMs = Number.isFinite(enqueueAt) ? enqueueAt : latest.bridgeEnqueueAtUnixMs;
        latest.bridgeServedAtUnixMs = Number.isFinite(sendAt)
          ? sendAt
          : (bi.servedAtUnixMs ?? state.lastBatchMeta?.servedAtUnixMs ?? latest.bridgeServedAtUnixMs);
        latest.enqueueAtUnixMs = Number.isFinite(enqueueAt) ? enqueueAt : latest.enqueueAtUnixMs;
        latest.sendAtUnixMs = Number.isFinite(sendAt) ? sendAt : latest.sendAtUnixMs;

        state.isConnected = true;
        state.netFailStreak = 0;

        processFrame(latest, nowPerf, handlerStartWall);
        const handlerEndPerf = performance.now();
        latest.jsProcessMs = Math.max(0, handlerEndPerf - handlerStartPerf);

        // Producer period approximation (kept for algo scoring / charts)
        const tP = (latest.sleep_Time || 100) + (latest.fullLoopTime_ms || 0);
        state.lastProducerPeriod = tP;

        // Still do scoring math each sample; no scheduling (SSE push model)
        const prevInterval = state.activeInterval;
        tickAlgoMetrics(coalesced, tP, prevInterval, state.activeInterval, NaN, NaN, false, "");
      };

      evtSource.onerror = () => {
        state.netFailStreak++;
        if (!state.hasData && state.netFailStreak >= 2) state.isConnected = false;

        // If we got "busy", we intentionally stop reconnecting
        if (sseHardDisabled) return;

        try { evtSource.close(); } catch {}
        evtSource = null;

        // Exponential-ish backoff, capped
        const wait = Math.min(5000, sseBackoffMs);
        sseBackoffMs = Math.min(5000, sseBackoffMs * 2);

        if (reconnectTimer) clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(startTelemetryStream, wait);
      };
    }

    function schedule(rec, tP) {
      const prevInterval = state.activeInterval;

      let sleep = config.UPDATE_INTERVAL_MS;

      let usedSmart = false;
      let sleepRaw = NaN;
      let sleepPostFactor = NaN;
      let algoCrashMsg = "";

      if (sleep === 0) {
        usedSmart = true;

        const fn = AlgorithmStrategies[config.ALGO_MODE];
        try {
          sleepRaw = fn ? fn(rec, tP, prevInterval) : 50;
          if (!Number.isFinite(sleepRaw)) sleepRaw = 50;
        } catch (e) {
          algoCrashMsg = e?.message || String(e);
          logEvent("Error", `Algo crash: ${algoCrashMsg}`);
          sleepRaw = 50;
        }

        sleepPostFactor = sleepRaw * config.MANUAL_UPDATE_FACTOR;
        sleep = sleepPostFactor;

        if (config.USE_BOUNDS_CHECK) sleep = Math.max(10, Math.min(sleep, 1000));
      }

      state.activeInterval = sleep;

      // Algo scoring + debug ring buffer (only when enabled)
      // if (config.ENABLE_ALGO_DEBUG) {
	  // Now we always do the math
	  const ALWAYS_DO_MATH = true;
	  if (ALWAYS_DO_MATH) {
        tickAlgoMetrics(rec, tP, prevInterval, sleep, sleepRaw, sleepPostFactor, usedSmart, algoCrashMsg);
      } else {
        clearAlgoDerivedTelemetry();
      }

      // SSE mode doesn't use a polling loop; placeholder keeps legacy math paths intact.
      setTimeout(() => {}, sleep);
    }

    function logFlagEvents(f) {
      Object.entries(EVENT_MESSAGES).forEach(([flag, def]) => {
        if (!f[flag]) return;
        const msg = typeof def.message === 'function' ? def.message(f) : def.message;
        if (msg) logEvent(def.type, msg);
      });
    }

    function processFrame(f, start, handlerStartWall) {
      state.frame = f;

      // Sequence gap tracking (queue dynamics + drop detection)
      const seq = Number(f.telemetry_sequence);
      if (Number.isFinite(seq)) {
        const prev = state.lastTelemetrySequence;
        f.telemetry_sequence_gap = Number.isFinite(prev) ? (seq - prev) : 0;
        state.lastTelemetrySequence = seq;
      } else {
        f.telemetry_sequence_gap = 0;
      }

      const nowWall = Number.isFinite(handlerStartWall) ? handlerStartWall : Date.now();
      const sampleAt = Number(f.sampleAtUnixMs);
      const enqueueAt = Number(f.enqueueAtUnixMs ?? f.bridgeEnqueueAtUnixMs ?? f.receivedAtUnixMs);
      const sendAt = Number(f.sendAtUnixMs ?? f.bridgeServedAtUnixMs ?? f.receivedAtUnixMs);

      const producerMs = (Number.isFinite(sampleAt) && Number.isFinite(enqueueAt)) ? Math.max(0, enqueueAt - sampleAt) : NaN;
      const queueWaitMs = (Number.isFinite(sendAt) && Number.isFinite(enqueueAt)) ? Math.max(0, sendAt - enqueueAt) : NaN;
      const handlerMs = Number.isFinite(sendAt)
        ? Math.max(0, nowWall - sendAt)
        : Math.max(0, performance.now() - start);

      const e2e = Number.isFinite(sampleAt) ? Math.max(0, nowWall - sampleAt) : NaN;
      const fallbackTotal = (f.fullLoopTime_ms||0) + (f.metricLoopProcessMs||0) + (f.metricHttpProcessMs||0) + handlerMs;
      const total = Number.isFinite(e2e) ? e2e : fallbackTotal;

      const pedVal = Number.isFinite(producerMs) ? producerMs : 0;
      const queueVal = Number.isFinite(queueWaitMs) ? queueWaitMs : 0;
      const handlerVal = Number.isFinite(handlerMs) ? handlerMs : 0;

      f.lagDash = handlerVal;
      f.queueWaitMs = queueWaitMs;
      f.producerLagMs = producerMs;
      f.lagTotal = total;
      f.lagE2E = e2e;
      f.activeUpdateInterval = state.activeInterval;
      f.pedDashGetCount = state.getCounter;
      f.algoMode = config.ALGO_MODE;

      state.target = {
        gasP: f.gas_physical_pct || 0,
        gasL: f.gas_logical_pct || 0,
        brP: f.brake_physical_pct || 0,
        brL: f.brake_logical_pct || 0,
        brRaw: f.rawBrake || 0,
        brNorm: f.brakeValue || 0,
        clP: f.clutch_physical_pct || 0,
        clL: f.clutch_logical_pct || 0,
        lagT: total,
        lagP: pedVal,
        lagB: queueVal,
        lagD: handlerVal,
        lagPaint: state.target.lagPaint || 0
      };

      logFlagEvents(f);

      const lagHistoryEntry = {
        t: Date.now(),
        total,
        ped: pedVal,
        brg: queueVal,
        dash: handlerVal,
        paint: Number.isFinite(f.lagPaint) ? f.lagPaint : NaN
      };

      pushHistory(state.lagHistory, lagHistoryEntry, MAX_CHART_HISTORY);

      pushHistory(state.pedalHistory, {
        t: Date.now(),
        gasP: f.gas_physical_pct || 0,
        brP: f.brake_physical_pct || 0,
        clP: f.clutch_physical_pct || 0
      }, MAX_CHART_HISTORY);

      calcAverages();

      if (Number.isFinite(sampleAt)) {
        const frameRef = f;
        requestAnimationFrame(() => {
          if (state.frame !== frameRef) return;
          const paintNow = Date.now();
          const lagPaint = Math.max(0, paintNow - sampleAt);
          frameRef.lagPaint = lagPaint;
          state.target.lagPaint = lagPaint;
          state.display.lagPaint = lagPaint;
          lagHistoryEntry.paint = lagPaint;
          calcAverages();
        });
      }

	// --- SAFETY WAKE-UP ---
	// Force the renderer to run at least one frame 
	// ensuring text flags/alerts update even if pedals are still.
	isIdle = false; 
		
    }

    function updateNonFrameMetrics(start) {
      // Keep lag display active even on empty frames
      const dLag = performance.now() - start;
      state.target.lagD = dLag;
      state.display.lagD = dLag;

      // Keep telemetry updated
      if (!state.frame) state.frame = {};
      state.frame.lagDash = dLag;
      state.frame.pedDashGetCount = state.getCounter;
      state.frame.algoMode = config.ALGO_MODE;
      state.frame.activeUpdateInterval = state.activeInterval;
    }

/**
 * 8. RENDERING
 */
// --- HYBRID OPTIMIZATION: Variables ---
let lastDrawTime = 0;
let isIdle = false;
const TARGET_FPS = 30;         // Cap animations at 30 FPS
const FRAME_INTERVAL = 1000 / TARGET_FPS;

function renderLoop(timestamp) {
  // 1. Keep the heartbeat alive (Browser calls this at 144Hz)
  requestAnimationFrame(renderLoop);

  // 2. THROTTLE: Exact 30 FPS Limit
  // If not enough time has passed since the last draw, exit immediately.
  // This effectively ignores 114 out of 144 frames per second.
  if (timestamp - lastDrawTime < FRAME_INTERVAL) return;

  // 3. SLEEP CHECK: Are the needles moving?
  // We calculate the difference between Target (Data) and Display (Screen)
  // If the difference is tiny (< 0.1), we assume visual silence.
  const dGas = Math.abs(state.target.gasP - state.display.gasP);
  const dBrake = Math.abs(state.target.brP - state.display.brP);
  const dClutch = Math.abs(state.target.clP - state.display.clP);
  const dLag = Math.max(
    Math.abs(state.target.lagT - state.display.lagT),
    Math.abs(state.target.lagPaint - state.display.lagPaint)
  ); // check lag ticker too

  // "Settled" means we are close enough to the target value
  const isSettled = (dGas < 0.1 && dBrake < 0.1 && dClutch < 0.1 && dLag < 1.0);

  // 4. DECISION:
  // If we are Settled AND Connected AND were already Idle last frame...
  // ...we DO NOT DRAW. (0% GPU usage here)
  if (isSettled && state.isConnected && isIdle) {
    return; 
  }

  // 5. UPDATE & DRAW (The expensive part)
  lastDrawTime = timestamp; // Reset the 30 FPS timer

  const l = 0.8; // Interpolation factor lerp
  state.display.gasP += (state.target.gasP - state.display.gasP) * l;
  state.display.gasL += (state.target.gasL - state.display.gasL) * l;
  state.display.brP  += (state.target.brP  - state.display.brP ) * l;
  state.display.brL  += (state.target.brL  - state.display.brL ) * l;
  state.display.brRaw = state.target.brRaw;
  state.display.brNorm = state.target.brNorm;
  state.display.clP  += (state.target.clP  - state.display.clP ) * l;
  state.display.clL  += (state.target.clL  - state.display.clL ) * l;

  state.display.lagT = state.target.lagT;
  state.display.lagP = state.target.lagP;
  state.display.lagB = state.target.lagB;
  state.display.lagD = state.target.lagD;
  state.display.lagPaint = state.target.lagPaint;

  renderUI();

  // 6. UPDATE STATUS
  // If we are settled now, mark idle as true so the NEXT frame can sleep.
  isIdle = isSettled;
}	  

    /**
     * 8. RENDERING
     */
/*
    function renderLoop() {
      const l = 0.2;
      state.display.gasP += (state.target.gasP - state.display.gasP) * l;
      state.display.gasL += (state.target.gasL - state.display.gasL) * l;
      state.display.brP  += (state.target.brP  - state.display.brP ) * l;
      state.display.brL  += (state.target.brL  - state.display.brL ) * l;
      state.display.brRaw = state.target.brRaw;
      state.display.brNorm = state.target.brNorm;
      state.display.clP  += (state.target.clP  - state.display.clP ) * l;
      state.display.clL  += (state.target.clL  - state.display.clL ) * l;

      // Lags snappy
      state.display.lagT = state.target.lagT;
      state.display.lagP = state.target.lagP;
      state.display.lagB = state.target.lagB;
      state.display.lagD = state.target.lagD;

      renderUI();
      requestAnimationFrame(renderLoop);
    }
*/

    function renderUI() {
      // Header status
      if (state.isConnected) {
        safeSetText(els.brandStatus, "Online");
        if (els.brandStatus) els.brandStatus.style.color = "var(--neon-green)";
      } else {
        safeSetText(els.brandStatus, "Connecting...");
        if (els.brandStatus) els.brandStatus.style.color = "#777";
      }

      // Disconnect indicator
      const disc = !state.isConnected || (state.frame && state.frame.controller_disconnected === 1);
      if (els.discInd) els.discInd.classList.toggle('active', disc);

      // FFW indicator (requested behavior)
      const rec = Number(state.frame?.framesReceivedLastFetch ?? 0);
      const ffw = Number.isFinite(rec) && rec > 1;
      if (els.ffwInd) els.ffwInd.classList.toggle('active', ffw);

      // Header metrics
      const headerLag = Number.isFinite(state.display.lagPaint) ? state.display.lagPaint : state.display.lagT;
      safeSetText(els.hdrTotal, (headerLag || 0).toFixed(0));
      safeSetText(els.hdrPed,   (state.display.lagP || 0).toFixed(0));
      safeSetText(els.hdrBrg,   (state.display.lagB || 0).toFixed(0));
      safeSetText(els.hdrDsh,   (state.display.lagD || 0).toFixed(0));
      safeSetText(els.hdrPaint, (state.display.lagPaint || 0).toFixed(0));

      if (state.currentTab === 'tab-racing') renderRacing();
      else if (state.currentTab === 'tab-lag') renderLag();
      else if (state.currentTab === 'tab-signals') renderSignals();
      else if (state.currentTab === 'tab-telemetry') renderTelemetry();
    }

    function renderRacing() {
      drawDualGauge(ctxClutch, "CLUTCH", state.display.clP, state.display.clL);
      drawDualGauge(ctxBrake, "BRAKE", state.display.brP, state.display.brL);
      drawDualGauge(ctxGas, "GAS", state.display.gasP, state.display.gasL);

      safeSetText(els.lblGasPhys, state.display.gasP.toFixed(0) + "%");
      safeSetText(els.lblGasLog,  state.display.gasL.toFixed(0) + "%");
      safeSetText(els.lblBrakePhys, state.display.brP.toFixed(0) + "%");
      safeSetText(els.lblBrakeLog,  state.display.brL.toFixed(0) + "%");
      safeSetText(els.lblClutchPhys, state.display.clP.toFixed(0) + "%");
      safeSetText(els.lblClutchLog,  state.display.clL.toFixed(0) + "%");

      const f = state.frame || {};
      toggleChip(els.stDrift,  f.gas_alert_triggered, 'active-red');
      toggleChip(els.stNoise,  f.clutch_alert_triggered, 'active-amber');
      toggleChip(els.stAuto,   f.gas_auto_adjust_applied, 'active-blue');
      toggleChip(els.stRacing, f.isRacing, 'active-green');
    }

    function renderLag() {
      safeSetText(els.cardPaint, (state.display.lagPaint||0).toFixed(0) + " ms");
      safeSetText(els.cardTotal, (state.display.lagT||0).toFixed(0) + " ms");
      safeSetText(els.cardPed,   (state.display.lagP||0).toFixed(0) + " ms");
      safeSetText(els.cardBrg,   (state.display.lagB||0).toFixed(0) + " ms");
      safeSetText(els.cardDsh,   (state.display.lagD||0).toFixed(0) + " ms");

      safeSetText(els.avgPaint, `Avg: ${state.avgLagPaint.toFixed(1)}`);
      safeSetText(els.avgTotal, `Avg: ${state.avgLagT.toFixed(1)}`);
      safeSetText(els.avgPed,   `Avg: ${state.avgLagP.toFixed(1)}`);
      safeSetText(els.avgBrg,   `Avg: ${state.avgLagB.toFixed(1)}`);
      safeSetText(els.avgDsh,   `Avg: ${state.avgLagD.toFixed(1)}`);

      resizeCanvas(els.cvsLag);
      drawHistoryChart(ctxLag, state.lagHistory, ['total', 'brg', 'dash', 'ped'],
        ['#ff3333', '#39ff14', '#ff00ff', '#00f3ff'], 0, null, true);
    }

    function renderSignals() {
      resizeCanvas(els.cvsWaveGas);
      resizeCanvas(els.cvsWaveClutch);
      drawHistoryChart(ctxWaveGas, state.pedalHistory, ['gasP'], ['#00f3ff'], 0, 100, false);
      drawHistoryChart(ctxWaveClutch, state.pedalHistory, ['clP'], ['#39ff14'], 0, 100, false);
    }

    function renderTelemetry() {
      const f = state.frame || {};
      Object.keys(TELE_DEFS).forEach(k => {
        let val = f[k];

        // keep framesReceivedLastFetch numeric (for warn-red)
        const isFramesRx = (k === 'framesReceivedLastFetch');
        const rawNum = typeof val === 'number' ? val : (val !== undefined ? Number(val) : NaN);

        // Formatting rules
        if (typeof val === 'number') {
          if (k === 'algoAccuracyPct') val = val.toFixed(3);
          else if (k === 'algoRunTimeSec') val = val.toFixed(1);
          else val = (val % 1 === 0) ? val : val.toFixed(1);
        }

        if (val === undefined) val = "--";

        const el = document.getElementById(`tele-${k}`);
        if (el) {
          el.textContent = val;
          if (isFramesRx) {
            const bad = Number.isFinite(rawNum) ? (rawNum !== 1) : false;
            el.classList.toggle('warn-red', bad);
          }
        }
      });
    }

    /**
     * 9. TELEMETRY UI BUILD
     */
    function getTelemetryGroupKeys(group) {
      if (group.title !== 'Diagnostics') return group.keys;

      // Only add algo scoring metrics when debug is enabled (requested behavior)
	  // Now we always show the algo scoring metrics
      // if (!config.ENABLE_ALGO_DEBUG) return group.keys;

      // Insert right after FRAMES RX card (most relevant location)
      const out = [];
      let inserted = false;
      group.keys.forEach(k => {
        out.push(k);
        if (k === 'framesReceivedLastFetch') {
          out.push(...ALGO_DEBUG_TELE_KEYS);
          inserted = true;
        }
      });
      if (!inserted) out.push(...ALGO_DEBUG_TELE_KEYS);
      return out;
    }

    function initTelemetryUI() {
      const container = document.getElementById('tele-container');
      if (!container) return;
      container.innerHTML = '';

      TELE_GROUPS.forEach(group => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'tele-group';

        const header = document.createElement('div');
        header.className = 'tele-group-header';
        header.textContent = group.title;
        groupDiv.appendChild(header);

        const gridDiv = document.createElement('div');
        gridDiv.className = 'tele-grid-section';

        const keys = getTelemetryGroupKeys(group);

        keys.forEach(key => {
          const def = TELE_DEFS[key] || { label: key, short: `${key}:`, long: "" };
          const card = document.createElement('div');
          card.className = 'tele-card';
          card.innerHTML = `<h5>${def.label}</h5><div class="tele-val" id="tele-${key}">--</div>`;

          card.onmouseenter = (e) => showHoverTip(e, def.short);
          card.onmousemove = (e) => moveHoverTip(e);
          card.onmouseleave = () => hideHoverTip();

          card.onclick = () => openTelemetryModal(def);

          gridDiv.appendChild(card);
        });

        groupDiv.appendChild(gridDiv);
        container.appendChild(groupDiv);
      });
    }

    function openTelemetryModal(def) {
      const title = document.getElementById('modal-title');
      const desc  = document.getElementById('modal-desc');
      const overlay = document.getElementById('modal-overlay');
      if (title) title.textContent = def.label;
      if (desc)  desc.textContent = def.long || "";
      if (overlay) overlay.classList.add('open');
    }

    function showHoverTip(e, txt) {
      const t = document.getElementById('hover-tip');
      if (!t) return;
      t.textContent = txt;
      t.classList.add('visible');
      moveHoverTip(e);
    }

    function moveHoverTip(e) {
      const t = document.getElementById('hover-tip');
      if (!t) return;
      t.style.left = (e.clientX + 15) + 'px';
      t.style.top  = (e.clientY + 15) + 'px';
    }

    function hideHoverTip() {
      const t = document.getElementById('hover-tip');
      if (t) t.classList.remove('visible');
    }

    function closeModal() {
      const overlay = document.getElementById('modal-overlay');
      if (overlay) overlay.classList.remove('open');
    }

    function initHeaderLagMetrics() {
      document.querySelectorAll('.lag-metric').forEach(el => {
        const key = el.dataset.teleKey;
        if (!key) return;
        const def = TELE_DEFS[key] || { label: key, short: `${key}:`, long: "" };

        el.addEventListener('mouseenter', (e) => showHoverTip(e, def.short));
        el.addEventListener('mousemove', (e) => moveHoverTip(e));
        el.addEventListener('mouseleave', () => hideHoverTip());
        el.addEventListener('click', () => openTelemetryModal(def));
      });
    }

    /**
     * 10. INITIALIZATION
     */
    window.onload = function() {
      // Cache DOM
      els = {
        brandStatus: document.getElementById('session-status'),
        discInd: document.getElementById('disc-indicator'),
        ffwInd: document.getElementById('ffw-indicator'),
        hdrTotal: document.getElementById('hdr-total-lag'),
        hdrPed: document.getElementById('hdr-ped-lag'),
        hdrBrg: document.getElementById('hdr-brg-lag'),
        hdrDsh: document.getElementById('hdr-dsh-lag'),
        hdrPaint: document.getElementById('hdr-paint-lag'),

        cvsGas: document.getElementById('canvas-gas'),
        cvsBrake: document.getElementById('canvas-brake'),
        cvsClutch: document.getElementById('canvas-clutch'),
        lblGasPhys: document.getElementById('lbl-gas-phys'),
        lblGasLog: document.getElementById('lbl-gas-log'),
        lblBrakePhys: document.getElementById('lbl-brake-phys'),
        lblBrakeLog: document.getElementById('lbl-brake-log'),
        lblClutchPhys: document.getElementById('lbl-clutch-phys'),
        lblClutchLog: document.getElementById('lbl-clutch-log'),

        stDrift: document.getElementById('status-drift'),
        stNoise: document.getElementById('status-noise'),
        stAuto: document.getElementById('status-auto'),
        stRacing: document.getElementById('status-racing'),

        tickerList: document.getElementById('ticker-list'),

        cardPaint: document.getElementById('card-total-paint'),
        cardTotal: document.getElementById('card-total-lag'),
        cardPed: document.getElementById('card-ped-lag'),
        cardBrg: document.getElementById('card-brg-lag'),
        cardDsh: document.getElementById('card-dsh-lag'),
        avgPaint: document.getElementById('avg-total-paint'),
        avgTotal: document.getElementById('avg-total-lag'),
        avgPed: document.getElementById('avg-ped-lag'),
        avgBrg: document.getElementById('avg-brg-lag'),
        avgDsh: document.getElementById('avg-dsh-lag'),

        cvsLag: document.getElementById('canvas-lag-chart'),
        cvsWaveGas: document.getElementById('canvas-wave-gas'),
        cvsWaveClutch: document.getElementById('canvas-wave-clutch'),

        fullEventList: document.getElementById('full-event-list')
      };

      ctxGas = els.cvsGas ? els.cvsGas.getContext('2d') : null;
      ctxBrake = els.cvsBrake ? els.cvsBrake.getContext('2d') : null;
      ctxClutch = els.cvsClutch ? els.cvsClutch.getContext('2d') : null;
      ctxLag = els.cvsLag ? els.cvsLag.getContext('2d') : null;
      ctxWaveGas = els.cvsWaveGas ? els.cvsWaveGas.getContext('2d') : null;
      ctxWaveClutch = els.cvsWaveClutch ? els.cvsWaveClutch.getContext('2d') : null;

      initConfigControls();

      // Initialize ring and metrics
      initAlgoRing(config.MAX_HISTORY_LINES);
      resetAlgoMetrics();

      initTelemetryUI();
      initHeaderLagMetrics();
      logEvent("System", "Initializing Dashboard...");
      renderLoop();
      startTelemetryStream();
    };

    // Expose functions for inline HTML onclick handlers (robust across environments)
    window.switchTab = switchTab;
    window.updateConfig = updateConfig;
    window.exportLogs = exportLogs;
    window.exportAlgoDebugCsv = exportAlgoDebugCsv;
    window.closeModal = closeModal;
  </script>
</body>
</html>
